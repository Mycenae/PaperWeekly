# How to Use SimPoint to Pick Simulation Points

Greg Hamerly, Erez Perelman, Brad Calder @ UCSD

## 1. Introduction

Understanding the cycle level behavior of a processor running an application is crucial to modern computer architecture research. To gain this understanding, detailed cycle level simulators are typically employed. Unfortunately, this level of detail comes at the cost of speed, and simulating the full execution of an industry standard benchmark on even the fastest simulator can take weeks to months to complete. This fact has not gone unnoticed, and several techniques have been developed aimed at reducing simulation time.

理解处理器运行一个程序的周期级行为，对于现代计算机架构研究是很关键的。为获得这种理解，一般会采用详细的周期级仿真器。不幸的是，这种级别的细节，其代价就是速度，在最快的仿真器上，仿真一个工业级的基准测试的完整运行，要几周到几个月才能完成。已经提出了几种技术来减少仿真时间。

For architecture research it is necessary to take one instance of a program with a given input, and simulate its performance over many different configurations for an architecture feature, searching the design space for Pareto optimal points in terms of performance, area and power. The same program binary with the input may be run hundreds or thousands of times to examine how, for example, the effectiveness of a given architecture changes with its cache size. To address these issues, we created a tool called SimPoint [11, 12, 10, 1, 7]. SimPoint intelligently chooses a set of samples called Simulation Points to perform targeted program analysis. These provide an accurate picture of the complete execution of the program. The SimPoint software can be downloaded at: http://www.cse.ucsd.edu/users/calder/simpoint/

对于架构研究，需要对一个程序与给定的输入，在一个架构特征在多种不同的配置下仿真其性能，对性能，面积和功耗，搜索设计空间的Pareto最优点。同样的程序binary以及输入，会运行成百上千次，以检查一些有效性，比如，一种给定架构，在改变其cache大小后的效果。为处理这些问题，我们创建了一个工具SimPoint，可以智能的选取一个样本集，称为仿真点，以进行目标程序分析，这会给出程序完整执行的精确描述。

SimPoint is one specific use of our off-line phase clustering approach [12] motivated by the need to perform efficient and accurate program analysis and architecture simulation, and several researchers in academia and at Intel are using SimPoint to accurately guide their architecture simulation research.

SimPoint是我们的离线阶段聚类方法的一个特定应用，该方法是受到要进行高效和精确的程序分析和架构仿真的需求推动而提出的，学术界和Intel的几个研究者正使用SimPoint来引导其架构仿真研究。

## 2. Automatically Finding Phase Behavior

In this section we provide a brief overview of phase analysis and the clustering approach to group similar parts of a program’s execution together.

在本节中，我们给出阶段分析和聚类方法的概览，将程序执行中类似的部分进行分组。

### 2.1 Phase Behavior

The way a program behaves over time is not totally random; in fact, it often falls into repeating behaviors, which we call phases. Automatically identifying this phase behavior is the goal of our research presented by Sherwood et.al. [12], and the key to unlocking many new optimizations.

程序随着时间的进行表现出的行为并不是完全随机的；实际上，程序通常表现出重复的行为，我们称之为阶段。自动识别这些阶段行为，是我们在Sherwood等[12]中的研究目标，是解锁很多新优化的关键。

To identify phases, we break a program’s execution into contiguous non-overlapping intervals. An interval is a continuous portion of execution (a slice in time) of a program. For our studies we have used interval sizes of 1 million, 10 million and 100 million instructions [10], and we are currently examining a variable interval size SimPoint algorithm. A phase is a set of intervals within a program’s execution that have similar behavior, regardless of temporal adjacency. This means that a phase may appear many times as a program executes. Phase classification partitions a set of intervals into phases with similar behavior. The phases that we discover are specific to the input used to run the program.

为识别这些阶段，我们将一个程序的执行分解成连续的不重叠的区间。一个区间是程序执行的一个连续部分。对我们的研究，我们使用的区间大小为一百万，一千万和一亿条指令，我们目前正在试验一种变化区间大小的SimPoint算法。一个阶段是程序执行中有类似行为的区间集合。而不需要在意其时间上的邻接性。这意味着，在程序执行中，一个阶段会出现很多次。阶段分类将区间集合分割成有相似行为的阶段。我们发现的阶段，对运行程序的不同的输入是不同的。

The key observation for phase recognition is that any program metric is a direct function of the way a program traverses the code during execution. We can find this phase behavior and classify it by examining only the ratios in which different regions of code are being executed over time. We can simply and quickly collect this information using code profiles. Accurately capturing phase behavior by only examining program or ISA-level metrics, independent of the underlying architectural details and performance, allows us to choose architecture independent simulation points. This means that it is possible to use phase information to guide many optimizations and policy decisions across different architecture configurations when performing a design space search.

阶段识别的关键观察是，任何程序度量，都是程序在执行的时候遍历代码的方式的函数。我们找到这些阶段的行为并对其分类，要通过检查不同的代码区域随着时间执行的比例。我们使用代码profiles来直接快速的收集这些信息。只通过检验程序级或ISA级的度量，与下层的架构细节和性能无关，精确的捕获阶段行为，使我们可以选择与架构无关的仿真点。这意味着，是可能用阶段信息，在进行设计空间搜索时，来在很多不同的架构配置中，引导很多优化和策略决策。

### 2.2 Profiling Granularity

SimPoint uses the phases generated by the off-line analysis to intelligently choose where to spend simulation time. At the highest level, SimPoint calculates phases for a program/input pair, and then chooses a single representative from each phase. The representative for each phase is chosen by finding the interval most similar to the average behavior of the phase. This representative interval for a phase is called a simulation point for that phase. Users can then perform program analysis or collect statistics on detailed simulation only on these simulation points. The whole program’s behavior is then estimated by combining the weighted performance results of each simulation point. The weights come from the size (proportion of the whole program) of the phase it comes from. This methodology allows SimPoint to significantly reduce program analysis and simulation time and provide an accurate characterization of the full program.

SimPoint使用离线分析生成的阶段，来智能的选择在哪里来花费仿真时间。在最高的层次上，SimPoint对一个程序/输入对来计算阶段，然后从每个阶段中选择一个最具有代表性的。每个阶段的代表的选择，是通过找到与阶段平均行为最类似的区间。一个阶段的代表性区间称为这个阶段的仿真点。用户可以只在这些仿真点上进行程序分析或在详细仿真上收集统计数据。权重来自于来自的阶段在整个程序中所占的比例。这种方法使SimPoint能显著减少程序分析和仿真时间，同时给出完整程序的精确特征刻画。

### 2.3 Data Structures Used to Capture Phase Behavior

The first step of our phase analysis is to quickly profile the frequency of the code being executed to create code signatures that represent the program’s behavior at different points during execution. These signatures, which are vectors, are then used along with several techniques from clustering analysis to concisely group together similar parts of the program’s execution into phases, or clusters.

我们阶段分析的第一步是快速给出要执行的代码的频率profile，以创建表示程序执行时在不同点上的行为特征。这些特征是向量，几种聚类分析技术用这些向量将程序执行的类似部分分组成阶段，或聚类。

#### 2.3.1 Basic Block Frequency Vectors

Our prior approach uses the Basic Block Vector (or BBV) [11] as a structure designed to capture information about changes in a program’s behavior over time. A basic block is a single-entry, single-exit section of code with no internal control flow. More formally, a Basic Block Vector is a one dimensional array, where each element in the array corresponds to one static basic block in the program. We start with a BBV containing all zeroes at the beginning of each interval. During each interval, we count the number of times each basic block in the program has been entered, and we record the count in the BBV. For example, if the 50th basic block is executed 15 times in an interval, then bbv[50] = 15 for that interval. In addition, we multiply each count by the number of instructions in the basic block, so basic blocks containing more instructions will have more weight in the BBV. Finally, at the end of each interval, we normalize the basic block vector by dividing each element by the sum of all the elements in the vector.

我们之前的方法使用BBV作为一个结构，来捕获程序随着时间的行为变化信息。一个basic block是一个单入口单出口的代码片段，中间没有内部控制流。更正式的，一个BBV是一个一维阵列，阵列中的每个元素对应着程序中的一个静态basic block。我们在每个区间的开始，以全零的BBV开始。在每个区间中，我们对程序中的每个basic block在本区间中进行计数，并记录在BBV中。例如，如果在一个区间中第50个basic block执行了15次，那么对这个区间bbv[50]=15。另外，我们将每个数量乘以在basic block中的指令数量，所以包含指令数多的basic blocks在BBV中的权重会更高。最后，在每个区间的最后，我们对BBV进行归一化。

We use BBVs to compare the intervals of the application’s execution. The intuition behind this is that the behavior of the program at a given time is directly related to the code executed during that interval [11]. We use the basic block vectors as signatures for each interval of execution: each vector tells us what portions of code are executed, and how frequently those portions of code are executed. By comparing BBVs of two intervals, we can evaluate the similarity of the two intervals. If two intervals have similar BBVs, then the two intervals spend about the same amount of time in roughly the same code, and therefore we expect the performance of those two intervals to be similar.

我们使用BBVs来比较应用执行的区间。这背后的直觉是，在给定时间内程序的行为，与这个区间中所执行的代码直接相关。我们使用BBV作为每个执行区间的特征：每个向量告诉我们，执行了哪些代码部分，以及这些代码部分执行的频率。通过比较两个区间的BBVs，我们可以评估两个区间的相似性。如果两个区间的BBV比较类似，那么这两个区间在大致相同的代码上花费了大致相同的时间，因此，我们期待这两个区间的性能是类似的。

Recently, we examined frequency vector structures other than basic block vectors for the purpose of phase classification. We have looked at frequency vectors for loops, procedures, register usage, instruction mix, and memory behavior [7]. We found that using register usage vectors, which simply count for a given interval the number of times each register is defined and used, provides similar accuracy to using basic block vectors. In addition, tracking only loop and procedure branch execution frequencies performed almost as well as using the full basic block information.

最近，我们调查了BBV以外的频率向量结构，以进行阶段分类。我们查看了对于循环，过程，寄存器使用，指令混合和内存行为的频率向量。我们发现，使用寄存器使用向量，对在给定区间中，每个寄存器定义和使用的次数进行计数，会得到与使用BBV类似的准确率。此外，追踪循环和过程的分支执行的频率，与使用完整的basic block信息得到几乎相同的表现。

### 2.4 Using Clustering for Phase Classification

Frequency vectors provide a compact and representative summary of the program’s behavior for each interval of execution. By examining the similarity between them, it is clear that there are high-level patterns in each program’s execution.

频率向量对每个执行区间，给出了一个紧凑的，有代表性的程序行为的摘要。检查频率向量之间的相似性，很清楚的是，在每个程序的执行中，有一些高层次的模式。

To exploit phase behavior, it is useful to have an automated way of extracting phase information from programs. To break the complete execution of the program into phases that have similar frequency vectors, clustering algorithms from the field of machine learning have been shown to be very effective [12].

为利用阶段的行为，就需要有一种从程序中自动提取阶段信息的方法。为将程序的完整执行分割成有类似频率向量的阶段，聚类算法非常有效。

Because the frequency vectors relate to the overall performance of the program, grouping intervals based on their frequency vectors produces phases that are similar not only in the distribution of program structures used, but also in every other architecture metric measured, including overall performance.

因为频率向量与程序的整体性能有关系，对区间基于其频率向量进行分组，得到的阶段不仅其使用的程序结构的分布类似，而且在其他的每个架构度量上都类似，包括整体的性能。

The goal of clustering is to divide a set of points into groups, or clusters, such that points within each cluster are similar to one another (by some metric, usually distance), and points in different clusters are different from one another. A well known clustering algorithm is k-means [8], which we use to accurately split program behavior into phases. We use random linear projection [4], which reduces the dimensionality of the input data while preserving the underlying similarity information, to speed up the execution of k-means. One drawback of the k-means algorithm is that it requires the number of clusters k as an input to the algorithm, but we do not know beforehand what value is appropriate. To address this, we run the algorithm for several values of k, and then use a goodness score to guide our final choice for k.

聚类的目标是将点集分组，或聚类，这样在每个聚类中的点是相互类似的（在某种度量下，通常是距离），在不同聚类中的点是相互不同的。一个著名的聚类算法是k-means，我们就使用这种算法将程序行为准确的分割成阶段。我们使用随机线性投影来对输入数据进行降维，同时保持潜在的相似性信息，以加速k-means的执行。k-means算法的一个缺点是，需要聚类的数量k作为算法的输入，但是我们目前是不知道哪个值是合适的。为解决这个问题，我们对几个k值多次运行算法，然后使用一个goodness分数来引导我们对k的最终选择。

Taking this to the extreme, if every interval of execution is given its very own cluster, then every cluster will have perfect homogeneous behavior. Our goal is to choose a clustering with a minimum number of clusters where each cluster has a certain level of homogeneous behavior.

在极端情况下，如果执行的每个区间都自成一个聚类，那么每个聚类都会有同样的行为。我们的目标是选择一种聚类数量最小的聚类方法，在每个聚类中都有一定程度的同样行为。

The following steps summarize the phase clustering algorithm at a high level. We refer the interested reader to [12] for a more detailed description of each step.

下面的步骤在高层中总结了阶段聚类算法。我们推荐感兴趣的读者参考[12]得到每个步骤的更详细的描述。

1. Profile the program by dividing the program’s execution into contiguous intervals of size N (e.g., 1 million, 10 million, or 100 million instructions). For each interval, collect a frequency vector tracking the program’s use of some program structure (basic blocks, loops, register usage, etc.). This generates a frequency vector for every interval. Each frequency vector is normalized so that the sum of all the elements equals 1.

将程序的执行分割成相邻的大小为N的区间（如，N为一百万，一千万或一亿条指令），然后得到程序的profile。对每个区间，收集一个频率向量，追踪程序对一些程序结构的使用（如，basic blocks，loops，register usage等）。这对每个区间都会生成一个频率向量。每个频率向量都进行归一化，这样每个元素之和为1。

2. Reduce the dimensionality of the frequency vector data to D dimensions using random linear projection. The advantage of performing clustering on projected data is that it speeds up the k-means algorithm significantly, and reduces the memory requirements by several orders of magnitude over using the original vectors, while preserving the essential similarity information.

使用随机线性投影将频率向量的维度降低到D维。在投影的数据上进行聚类的优势是，能够显著加速k-means算法，并将内存需求降低好几个数量级，同时保持了关键的相似性信息。

3. Run the k-means clustering algorithm on the reduced dimensional data with values of k from 1 to K, where K (Max K) is the maximum number of phases that can be detected. Each run of k-means produces a clustering, which is a partition of the data into k different phases/clusters. Each run of k-means begins with a random initialization step, which requires a random seed.

在降维的数据上运行k-means聚类算法，k取值为1到K，其中K是可以检测到的阶段最大数量。每次运行k-means产生一种聚类结果，将数据分割成了k种不同的阶段/聚类。每次运行k-means都以一个随机初始化步骤开始，这需要一个随机种子。

4. To compare and evaluate the different clusters formed for different k, we use the Bayesian Information Criterion (BIC) [9] as a measure of the “goodness of fit” of a clustering to a dataset. More formally, the BIC is an approximation to the probability of the clustering given the data that has been clustered. Thus, the larger the BIC score, the higher the probability that the clustering is a good fit to the data. For each clustering (k = 1 ...M), the fitness of the clustering is scored using the BIC formulation given in [9].

为比较和评估不同的k形成的不同聚类，我们使用BIC作为数据集的一种聚类的goodness of fit的度量。更正式的，BIC是在数据聚类完之后，聚类的概率的近似。因此，BIC分数越高，这个聚类是数据的很好的拟合的概率越高，对每种聚类(k = 1 ...M)，聚类的拟合程度使用[9]中的BIC公式进行评分。

5. The final step is to choose the clustering with the smallest k, such that its BIC score is at least B% as good as the best score. The clustering k chosen is the final grouping of intervals into phases.

最后的步骤是选择最小k的聚类，这样其BIC分数是最好分数的至少B%。选择的聚类k是将区间分组成的阶段数。

The above algorithm groups intervals into phases. We use the Euclidean distance between vectors as our similarity metric. This algorithm has important parameters (N, D, K, B, and more) to tune to create accurate and representative simulation points using SimPoint. We discuss these parameters in detail in Section 5.

上面的算法将区间分组成阶段。我们使用向量之间的欧式距离作为我们的相似性度量。这个算法有一些重要的参数(N, D, K, B, and more)要进行调整，以使用SimPoint创建精确和有代表性的仿真点。我们在第5部分详细讨论这些参数。

## 3. How SimPoint Chooses Simulation Points

After the phase classification algorithm described in the previous section has done its job, intervals with similar code usage will be grouped together into the same phase, or cluster. Then from each phase, we choose one representative interval that will be simulated in detail to represent the behavior of the whole phase. Therefore, by simulating only one representative interval per phase, we can extrapolate and capture the behavior of the entire program.

在上一节描述的阶段分类算法完成了其工作之后，有类似代码用途的区间会分组到相同的阶段，或聚类中。然后从每个阶段中，然后从每个阶段中，我们选择一个有代表性的区间，进行详细的仿真，以代表整个阶段的行为。因此，通过只仿真每个状态中一个有代表性的区间，我们可以外插并捕获到整个程序的行为。

To choose a representative, SimPoint picks the interval that is closest to the center, or centroid, of each cluster. The centroid is the average of all the intervals in the cluster. This is analogous to the center of mass of all the points that are in that cluster. It can also be viewed as the interval which behaves most like the average behavior of the entire phase. Most likely there is no interval that exactly matches the centroid, so the interval closest to the centroid is chosen. The selected interval is called a Simulation Point for that phase [10, 12]. Detailed simulation is then performed on the set of simulation points.

为选择一个代表，SimPoint选择的是与每个聚类的中心（或重心）最接近的区间。重心是聚类中所有区间的平均，这与这个聚类中所有点的质量中心是类似的。这也可以视为，与整个状态的平均行为最接近的区间。最可能的是，没有哪个区间会严格的与重心一样，所以会选择与重心最接近的区间。选定的这个区间称为这个状态的仿真点。然后就在这些仿真点集上进行详细仿真。

SimPoint outputs a weight for each simulation point. Each weight is a fraction: the number of instructions in the cluster from which the simulation point was taken over the number of instructions in the program. With the weights and the detailed simulation results of each simulation point, we compute a weighted average that is accurate for the complete execution of the program/input pair.

SimPoint对每个仿真点输出一个权重。每个权重是一个部分比例：取仿真点所在的聚类中的指令数量，占程序中所有指令数量的比例。有了权重，和每个仿真点的仿真结果，我们可以计算一个加权平均，这是程序/输入对的完整执行的精确近似。

## 4. Using the Simulation Points

After the SimPoint algorithm has chosen a set of simulation points and their respective weights, they can be used to accurately estimate the full execution of a program. The next step is to simulate in detail the interval for each simulation point, to collect the desired performance statistics.

在SimPoint选择了仿真点集及其对应了权重后，它们可以用于精确的估计程序的完整执行。下一步是详细仿真每个仿真点的区间，以收集期望的性能统计值。

### 4.1 Simulation Point Representation

SimPoint provides the simulation points in two forms: SimPoint以两种形式给出仿真点：

**Simulation Point Interval Number** – The interval number for each simulation point is given. The interval numbers are relative to the start of execution, not to the previous simulation point. To get the start of a simulation point, subtract 1 from the interval number, and multiply by the interval size. For example, interval number 15 with an interval size of 10 million instruction means that the simulation point starts at instruction 140 million (i.e. (15-1)*10M) from the start of execution. Detailed simulation of this simulation point would occur from instruction 140 million until just before 150 million.

仿真点的区间数值：给出每个仿真点的区间数值。区间数值是相对于执行开始的地方的，而不是相对于之前的仿真点。为得到一个仿真点开始的地方，从区间值上减去1，然后乘以区间大小。比如，区间值15，区间大小为一千万条指令，意味着仿真点开始于从开始执行的地方指令1.4亿条处。这个仿真点的详细仿真从指令1.4亿条，直到1.5亿条之前。

**Start PC with Execution Count** – SimPoint also provides for each simulation point the program counter for the first instruction of the interval and the number of times that instruction needs to be executed before starting simulation. For example, if the PC is 0x12000340 with an execution count of 1000, then detailed simulation starts the 1000th time that PC is seen during execution, and simulation occurs for the length of the profile interval.

起始PC和执行数量：在开始仿真之前，SimPoint还可以对每个仿真点提供区间的第一条指令的PC，和这些指令需要执行的次数。比如，如果PC为0x12000340，执行次数为1000，那么详细的仿真要执行1000次，每次都要在执行中看到这条PC，仿真的长度为区间大小。

### 4.2 Simulating the Points

After choosing the form of simulation points to use, each simulation point is then simulated. Two standard approaches for doing this are to use either fast-forwarding or checkpointing.

在选择了要使用的仿真点的形式后，每个仿真点然后进行仿真。有两种进行仿真的标准方法，为fast-forwarding或checkpointing。

**Fast-Forwarding** – Sort the simulation points in chronological order. Fast-forward to the start of each simulation point. Simulate at the desired detail for the size of the interval. Repeat these steps, fast-forwarding from one point to the next combined with detailed simulation, until all simulation intervals have been collected.

将仿真点按时间顺序进行排列。快进到每个仿真点的起始。对区间大小的范围内，按照期望的细节程度进行仿真。重复这些步骤，从一个点快进到下一个，直到所有仿真区间都收集到了。

**Checkpointing** – One advantage of SimPoint is that the state of a program can be checkpointed (e.g., using SimpleScalar’s checkpoint facility) right before the start of each simulation point. This checkpointing allows parallel simulation of all of the simulation points at once.

SimPoint的一个优点是，程序的状态可以在每个仿真点之前进行checkpoint（如，使用SimpleScalar的checkpoint工具）。有了这种checkpoint，就可以在所有的仿真点处进行一次性的并行仿真。

### 4.3 Warmup

When using simulation points, an approach is needed for warming up the architecture state (e.g., the caches, TLBs, and branch predictor). The following are some standard approaches for dealing with warmup.

当使用仿真点时，需要一种方法来预热架构状态（如，缓存，TLBs，和分支预测器）。下面是一些处理预热的标准方法。

**No Warmup** – If a large enough interval size is used (e.g., 100 million instructions), no warmup may be necessary for many programs.

如果使用了足够大的区间大小（如，1亿条指令），对很多程序而言就不需要进行预热。

**Assume Hit (Remove Cold Start Misses)** – All of the large architecture structures (e.g., cache, branch predictors) make use of a warmup bit that indicates when is the first time an entry is used. If it is the first time, the access is assumed to be a hit or a correct prediction. One can also use a miss rate percentage (e.g., 10%) for these cold start misses, randomly assuming some percentage of the cold start accesses are misses. This a very simple method that provides fairly accurate warmup state, since the miss rates for these structures are usually fairly low [13, 6].

假设命中（去除冷启动的未命中）：所有的大型架构结构（如，缓存，分支预测器）使用一个预热bit，指示一个entry第一次使用的时间。如果是第一次使用，这次访问就假设是命中的，或正确的预测。也可以对这些冷启动misses使用一个miss率百分比（如，10%），随机假设冷启动访问的一些比例是misses。这是一种非常简单的方法，给出相当精确的预热状态，因为这些结构的miss率一般是相当低的。

**Stale State** – This is a method of not resetting the architecture structures between simulation points, and instead they are used in the state they were in at the end of the prior simulation point we just fast-forwarded from [3].

陈旧的状态：这是在仿真点之间并不重设架构结构的方法，而是使用快进来之前的前一个仿真点的状态。

**Calculated Warmup** – One can calculate the working set of the most recently accessed data, code and branch addresses before a simulation point. Then start the simulation of architectural components W instructions before the simulation point, where W is large enough to capture the working set size held by the architecture structures. After these W instructions are simulated, then reset any statistics and start the detailed simulation for that point. This approach brings the working set back into the architecture structures before starting the detailed simulation [2, 5].

计算得到的预热：可以计算得到在一个仿真点之前，最近访问的数据，代码和分支地址的working set。然后在仿真点之前的W条指令处，开始架构组成部分的仿真，其中W要足够大，以捕获架构结构保持的working set大小。在这W条指令被仿真后，然后重置所有的统计数据，然后开始这个点的详细仿真。这种方法将working set放入到架构结构中，然后再开始详细的仿真。

**Continuously Warm** – This approach continuously keeps the state of certain architecture components warm (e.g., caches) even during fast-forwarding [14]. This is feasible if an infrastructure provides fast functional and structure simulation during fast-forwarding. Keeping the cache structures warm will increase the time it takes to perform fast-forwarding, but it is very accurate.

这种方法即使是在快进的时候，连续的保持特定的架构组成部分是热的（如，缓存）。如果基础设施在快进的时候给出快速的功能性的和结构仿真，那么就是可行的。保持缓存结构是热的，会增加快进进行的时间，但却是非常精确的。

Either Calculated Warmup or Continuous Warmup provides the most accuracy, although we have found that for many programs Assume Hit and Stale State are fairly accurate.

Calculated Warmup或Continuous Warmup给出的准确率最高，但我们发现，对于很多程序来说，Assume Hit和Stale State也是相当精确的。

### 4.4 Combining the Simulation Point Results

The final step in using SimPoint is to combine the weighted simulation points to arrive at an overall performance estimate for the program’s execution. One cannot just use the harmonic mean for computing the overall miss rate, since we need to apply a weight to each sample.

使用SimPoint的最终步骤，是仿真点结果加权结合到一起，得到程序执行的总体性能估计。不能仅仅使用调和平均数来计算总体的miss率，因为我们还需要对每个样本进行加权。

Each weight represents the proportion of the total execution that belongs to its phase. The overall performance estimate is the weighted average of the set of simulation point estimates. For example, if we have 3 simulation points and their weights are [.22, .33, .45] and their CPIs are (CPI1, CPI2, CPI3), then the weighted average of these points is: CPI = 0.22 ∗ CPI1+0.33 ∗ CPI2+0.45 ∗ CPI3

每个权重表示在总体执行中，属于这个状态的比例。总体性能估计，是仿真点估计的集合的加权平均。比如，如果我们有3个仿真点，其权重分别为[.22, .33, .45]，其CPIs分别为(CPI1, CPI2, CPI3)，那么这些点的加权平均为：CPI = 0.22 ∗ CPI1+0.33 ∗ CPI2+0.45 ∗ CPI3

The weighted average CPI is the estimate of the CPI for the full execution. 加权平均CPI是完整执行的CPI的估计。

### 4.5 Pitfalls to Watch for When Using Simulation Points

There are a few important potential pitfalls worth addressing to ensure accurate use of SimPoint’s simulation points.

在使用SimPoint的仿真点时，为确保准确，有一些很重要的潜在的隐患。

**Calculating Weighted IPC** – For IPC (instructions/cycle) we cannot just apply the weights as above. We first would need to convert all the simulated samples to CPI before computing the weighted average as above, and then convert the result back to IPC.

计算加权的IPC：对于IPC (instructions/cycle)，我们不能仅仅应用上面的权重。我们首先需要将所有仿真的样本转换成CPI，然后按照上面所说的计算加权平均，然后将结果转换回IPC。

**Calculating Weighted Miss Rates** – To compute an overall miss rate, this must be calculated using the weighted average. To compute the overall miss rate, we calculate the weighted average as is shown above for CPI, but replace the CPI estimates with the miss rate estimates.

计算加权miss率：为计算总体miss率，必须使用加权平均来计算。为计算整体miss率，我们要像计算CPI一样计算加权平均，但要把CPI估计替换为miss率估计。

**Accurate Instruction Counts (No-ops)** – It is important to count instructions exactly the same for the BBV profiles as for the detailed simulation, otherwise they will diverge. Note that the simulation points on the SimPoint website include no-ops in the instruction counts, so to reach a simulation point in a simulator, all executed instructions must be counted.

精确的指令数量：在进行详细仿真时，指令数量的计数，要与BBV profiles中的指令数量要严格一致，否则就会有偏差。注意，SimPoint网站上的仿真点，在指令数量中包含了no-ops，所以要在仿真器中达到一个仿真点，所有执行的指令都要进行计数。

**System Call Effects** – Some users have reported system call effects when running the same simulation points under slightly different OS configurations on a cluster. This occurs when using the simulation point interval numbers. To avoid this, we suggest using the Start PC and Execution Count for each simulation point as described above.

系统调用效果：一些用户在一个集群中，在略微不同的OS配置下，在运行相同的仿真点时，汇报了系统调用的效果。这在使用仿真点区间数的时候发生。为避免这样，我们建议对每个仿真点使用起始PC和执行计数，如上所述。

### 4.6 Results

We now show the accuracy of using SimPoint for the complete SPEC 2000 benchmark suite and their reference inputs. Figure 1 shows the simulation accuracy results using SimPoint for the SPEC 2000 programs when compared to the complete execution of the programs. Results are shown for the median, average and maximum errors found. For these results, we set N (the number of instructions per interval) to 1 million, M (the maximum value of k) to 100, we try 7 different random seeds for each value of k, and we set X (the BIC score threshold, relative to the range of the observed BIC scores) to 90%.

我们现在展示对完整的SPEC 2000基准测试包及其参考输入，使用SimPoint得到的准确率。图1展示了对SPEC 2000程序使用SimPoint，相对于完全执行程序的仿真准确率。给出了发现的中值，平均和最大误差结果。对这些结果，我们设N为一百万（即每个区间的指令数量），M为100（即k的最大值），我们对每个k值尝试7个不同的随机种子，设X为90%（BIC分数阈值，相对于观测到的BIC分数）。

For the non-SimPoint results, a simulation is run for 300 million instructions, which is over 3 times that of the SimPoint results provided. Figure 1 shows that starting simulation at the start of the program results in an average CPI error of 201% when compared to the full simulation of the program, whereas blindly fast forwarding for 1 billion instructions and then starting simulation results in an average CPI error of 99%. When using the SimPoint algorithm to create multiple simulation points we saw an average CPI error of 2.1%. In comparison to random sampling approaches, we have found that SimPoint is able to achieve similar error rates requiring significantly (5 times) less simulation (fast-forwarding) time [10]. In addition, statistical sampling can be combined with SimPoint to create a phase clustering that has a low per-phase variance [10].

对于非SimPoint结果，一次仿真运行了3亿条指令，这是SimPoint的结果的3倍。图1展示了，从程序开始时进行仿真所得到的平均CPI误差，与程序的完整仿真相比，为201%，而盲目快进10亿条指令后然后开始仿真，得到的平均CPI误差为99%。当使用SimPoint算法，创建多个仿真点，我们得到的平均CPI误差为2.1%。余随机采样方法相比，我们发现SimPoint在得到类似的误差率时，所需要的仿真时间会极大减少（5倍）。此外，统计采样可以与SimPoint结合到一起，以创建状态内方差较低的状态聚类。

### 4.7 Architecture Independence

The absolute error of a program/input run on one hardware configuration is not as important as tracking the change in metrics across different architecture configurations. We now examine how SimPoint tracks the relative change in hardware metrics across several different architecture configurations. To examine the independence of our simulation points from the underlying architecture, we used the simulation points for the BIC SimPoint algorithm with 1 million intervals and max K set to 300. For the program/input runs we examine, we performed full program simulations varying the memory hierarchy, and for every run we used the same set of simulation points when calculating the SimPoint estimates. We varied the configurations and the latencies of the L1 and L2 caches as described in [10].

一个程序/输入对在一种硬件配置上运行的绝对误差，并没有追踪在不同的架构配置上的度量变化更加重要。我们现在检查SimPoint在几种不同的架构配置下怎样追踪硬件度量的相对变化。为检查我们的仿真点是独立于底层的架构的，我们使用的仿真点区间大小为一百万，max K设置为300，带有BIC的SimPoint算法，我们在进行完整程序仿真的时候，对内存层次结构进行变化，对每次运行，我们使用相同的仿真点集合，进行计算SimPoint估计。我们对L1和L2缓存的配置和延迟的变化，和[10]中一样。

Figure 2 shows the results across the 19 different architecture configurations we examined for three programs from the SPEC benchmark suite gcc-166. The left y-axis represents the performance in Instructions Per Cycle and the x-axis represents different memory configurations from the baseline architecture. The right y-axis shows the miss rates for the data cache and unified L2 cache, and the L2 miss rate is a local miss rate. For each metric, two lines are shown, one for the true metric from the complete detailed simulation for every configuration, and the second for the estimated metric using our simulation points. For each graph, the configurations on the x-axis are sorted by the IPC of the full run.

图2展示了在19种不同的架构配置下，我们对SPEC基准测试包gcc-166下的三个程序进行检查的结果。左边的y轴表示以IPC表示的性能，x轴表示不同的内存配置。右边的y轴展示了对数据cache和统一的L2 cache的miss率，L2 miss率是一个局部miss率。对每个度量，展示两条线，一个是对每种配置进行完整的详细仿真得到的真值度量，第二个是使用我们的仿真点得到的估计度量。对每个图，x轴上的配置是以完整运行的IPC进行排序的。

Figure 2 shows that the simulation points, which are chosen by only looking at code usage, can be used across different architecture configurations to make accurate architecture design trade-off decisions and comparisons. These results show that simulation points track the relative change in metrics between configurations. One interesting observation is that although the simulation results from SimPoint have a bias in the metrics, this bias is consistent and always in the same direction across the different configurations for a given program/input run. This is true for both IPC and cache miss rates. One reason for this bias is that SimPoint chooses the most representative interval from each phase, and intervals that represent phase changes may (if they occur enough) or may not (if they do not occur enough) be represented by a simulation point.

图2展示了，只查看代码用途选择出的仿真点，可以在不同的架构配置下使用，以对架构设计折中进行精确的决策和比较。这些结果表明，仿真点可以追踪不同配置间的度量相对变化。一种有趣的观察是，虽然SimPoint得到的仿真结果在度量上有一定偏差，但这种偏差是一致的，对一个给定的程序/输入对，在不同的配置中，偏差一直在相同的方向上。这对于IPC和cache miss率都是对的。这种偏差的一个原因是，SimPoint从每个状态中选择了最有代表性的区间，而代表了状态变化的区间可能由一个仿真点代表，也可能不能由一个仿真点代表。

## 5. Creating Your Own Simulation Points

We now describe how to set the SimPoint parameters to create your own simulation points. The following are the parameters when using SimPoint:

我们现在描述怎样设置SimPoint参数，才能创建你自己的仿真点。下面是使用SimPoint时的参数：

**Size of interval** – The number of instructions per interval is the granularity of the algorithm. The interval size directly relates to the number of intervals, since the dynamic program length is the number of intervals times the interval size. Larger intervals allow more aggregate profile (basic block vector) representations of the program, while smaller intervals allow for more fine-grained representations. The interval size affects the number of simulation points; with smaller intervals more simulation points are needed than when using larger intervals to represent the same proportion of the program.

区间大小：每个区间的指令数量是算法的粒度。区间大小与区间数量直接相关，因为动态程序长度就是区间数量乘以区间大小。更大的区间表示程序的更聚积的profile (bbv)表示，而更小的区间就是更细粒度的表示。区间大小影响了仿真点的数量；更小的区间，就需要更多仿真点，而更大的区间，需要的仿真点就更少。

**Number of intervals** – There should be a fair number of intervals for the clustering algorithm to choose from. A good rule of thumb is to make sure you are using at least 1,000 intervals in order for the clustering algorithm to be able to find a good partition of the intervals. If there are too few intervals, then decrease the interval size to obtain more intervals for clustering.

区间数量：应当有很多数量的区间，聚类算法从中进行选择。一个首要规则是，确保至少在使用1000个区间，让聚类算法可以找到区间的很好的分割。如果区间数量过少，那么就降低区间大小，以得到更多的区间进行聚类。

**Max K** – The maximum number of clusters (K from Section 2), along with the interval size, represents the maximum amount of simulation time that will be needed when looking to choose simulation points. If SimPoint chooses a number of clusters that is close to the maximum allowed, then it is possible that Max K is too small. If this is the case and more simulation time is acceptable, it is better to double the Max K and re-run the SimPoint analysis.

Max K：聚类的最大数量，与区间大小一起，表示在选择仿真点时，需要的最长的仿真时间。如果SimPoint选择的聚类数量接近允许的最大数量，那么Max K的选择可能太小了。如果是这种情况，而且可以接受更多的仿真时间，那么最好将Max K加倍，重新运行SimPoint分析。

**Random Seeds** – The k-means clustering algorithm starts from a randomized initialization, which requires a random seed. It is well-known that k-means can produce very different results depending on its initialization, so it is good to use many different random seeds for initializing different k-means clusterings, and then allow SimPoint to choose the best clustering. We have found that in practice, using 7 random seeds works well.

随机种子：k-means聚类算法从随机初始化开始，这需要一个随机种子。k-means算法在不同的初始化下，会得到非常不同的结果，所以最好使用很多不同的随机种子来初始化不同的k-means聚类，然后允许SimPoint来选择最好的聚类。我们发现，在实践中，使用7个随机种子效果很好。

**Number of iterations** – The k-means algorithm iterates either until it hits a maximum number of iterations or until it reaches a point where no further improvement is possible (whichever is less). In most cases 100 iterations is sufficient for the maximum number, but more may be required, especially if the number of intervals is very large compared to the number of clusters. A very rough rule of thumb is the number of iterations should be set to $/sqrt_{N/k}$, where N is the number of intervals and k is the number of clusters.

迭代次数：k-means算法迭代进行，直到达到最大迭代次数，或直到无法进行改进。在多数情况下，100次迭代足以是最大迭代数量，但也可能需要更多，尤其是在区间数量比聚类数量大很多的情况下。一个很粗糙的规则是，迭代次数应当设置为$/sqrt_{N/k}$，其中N是区间数量，k是聚类数量。

**Number of dimensions** – SimPoint uses random linear projection to reduce the dimension of the clustered data, which dramatically reduces computational requirements while retaining the essential similarity information. SimPoint allows the user to define the number of dimensions to project down to. In our experiments we project down to 15 dimensions, as we have found that using it produces the same phases as using the full dimension. We believe this to be adequate for most SimPoint applications, but it is possible to test other values by looking at the consistency of the clusters produced when using different dimensions.

维数：SimPoint使用随机线性投影来降低聚类数据的维度，这可以极大降低计算需求，同时保持关键的相似性信息。SimPoint允许用户定义投影到的维度数量。在我们的试验中，我们投影到15维上，因为我们发现，这与使用完整维度产生相同的状态数。我们相信，对于多数SimPoint应用来说，这是足够的，但测试其他值也是可能的，查看使用不同的维度得到的聚类的一致性。

**BIC percent** – The BIC gives a measure of the goodness of the clustering of a set of data, and BIC scores can be compared for different clusterings of the same data. However, the BIC score is an approximation of a probability, and often increases as the number of clusters increase. This can lead to often selecting the clustering with the most clusters. Therefore, we look at the range of BIC scores, and select the score which attains some high percentage of this range (e.g. we use a BIC score of 90%). When the BIC rises and then levels off, this method chooses a clustering with the fewest clusters that is near the maximum value. Choosing a lower BIC percent would prefer fewer clusters, but at the risk of less accurate simulation.

BIC百分比：BIC给出了数据集的聚类的好坏程度的度量，BIC分数可用于比较相同数据的不同聚类结果。但是，BIC分数是一个概率的近似，通常会随着聚类数量的增加而增加。这可以导致，选择有最多聚类的聚类结果。因此，我们查看BIC分数的范围，选择的分数会在这个百分比的范围内（如，我们使用90%的BIC分数）。当BIC上涨，然后达到平稳，这种方法选择的聚类，有最小的聚类数，但是接近最大BIC值。选择较低的BIC会倾向于较少的聚类，但可能有仿真没那么精确的风险。

Creating simulation points with SimPoint is all about trading off accuracy for simulation time. If a user wants to limit the Max K to be small to limit simulation time, SimPoint can still provide accurate results. One reason for this is that for a given cluster a point close to the centroid (the average code usage of the cluster) is picked to represent the cluster. For example, limiting a clustering of gcc to be at most 300 clusters for an interval size of 1 million instructions, we have found the clusters formed to have very similar IPC. But, if the maximum number of clusters is only 10 using an interval size of 100 million, then some of the clusters will have varying IPC. The good news is that even in this case, since a point close to the centroid is chosen, this point represents the average code behavior of the interval, and this results in a low error rate.

用SimPoint创建仿真点，有很多准确率和仿真时间的折中。如果用户让Max K很小，以限制仿真时间，SimPoint仍然可以给出精确的结果。这其中的一个原因是，对一个给定的聚类，会选择接近重心的点来代表这个聚类。比如，限制gcc的聚类最多为300个聚类，区间大小为一百万指令，我们发现形成的聚类有非常相似的IPC。但是，如果聚类最大数量只是10，使用的区间大小为1亿，那么一些聚类的IPC就会不一样。好消息是，即使在这种情况下，由于选择了接近重心的点，这个点表示了这个区间中的平均代码行为，这仍然会得到较低的错误率。

We call the SimPoint algorithm we have focused on in this paper the Standard SimPoint approach. Another option for reducing simulation time is to use the Early SimPoint algorithm [10]. The Early SimPoint algorithm picks points which are close to the centroid, but not necessarily the closest, instead preferring points that are earlier in execution. This approach reduces the time it takes to complete the simulation of a program due to fast-forwarding.

我们称本文中的SimPoint方法为标准SimPoint方法。另一种减少仿真时间的选项是，使用早期SimPoint方法。早期SimPoint算法选择的点也是接近于重心的，但并不一定是最接近的，而是倾向于在执行中更早的点。这种方法也可以减少仿真一个程序的时间，因为可以快进。