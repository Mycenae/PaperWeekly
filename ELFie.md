# ELFies: Executable Region Checkpoints for Performance Analysis and Simulation

Harish Patil et. al. @ Intel Corporation & National University of Singapore

## 0. Abstract

We address the challenge faced in characterizing long-running workloads, namely how to reliably focus the detailed analysis on interesting execution regions. We present a set of tools that allows users to precisely capture any region of interest in program execution, and create a stand-alone executable, called an ELFie, from it. An ELFie starts with the same program state captured at the beginning of the region of interest and then executes natively. With ELFies, there is no fastforwarding to the region of interest needed or the uncertainty of reaching the region. ELFies can be fed to dynamic program analysis tools or simulators that work with regular program binaries. Our tool-chain is based on the PinPlay framework and requires no special hardware, operating system changes, recompilation, or re-linking of test programs. This paper describes the design of our ELFie generation tool-chain and the application of ELFies in performance analysis and simulation of regions of interest in popular long-running single and multi-threaded benchmarks.

在刻画长期运行的workloads时会面临挑战，即怎样可靠的聚焦在感兴趣执行区域的详细分析上，我们来处理这个挑战。我们给出工具集，使用户可以精确的捕获程序执行中的任意感兴趣区域，从中创建一个独立的可运行程序，称为ELFie。一个ELFie开始的程序状态，与在感兴趣区域捕获的状态相同，然后进行本地执行。有了ELFies，就不需要快进到感兴趣区域了，以及到达该区域的不确定性。ELFies可以作为动态程序分析工具的输入，或仿真器的输入，而它们的输入一般都是常规的程序binaries。我们的工具链是基于PinPlay框架的，不需要任何特殊的硬件，操作系统变化，测试程序的重编译，或重链接。本文描述了我们的ELFie生成工具链的设计，以及在长期运行的单线程和多线程基准测试中，ELFies在性能分析和感兴趣区域仿真中的应用。

**Index Terms** — record and replay, dynamic program analysis, performance monitoring, simulation region selection

## 1. Introduction

Workload characterization is the process of understanding the behavior of computer systems. Characterization can be performed for the whole system or for individual programs. Typical characterization approaches include using hardware performance counters, program instrumentation with tools such as Pin [1], and performance simulation [2]–[4]. These approaches incur a varying amount of overhead depending on the degree of detail they provide. Since the detailed analysis of entire program runs can be prohibitively expensive, most approaches use sampling techniques to focus on key regions of interest [5]–[7]. Phase-based sampling techniques, such as SimPoint [5], are very effective in finding representative regions for architecture simulation. However, finding regions of interest can be time-consuming and it is desirable to be able to share such regions among researchers so the cost of generating them is amortized. One challenge is how to re-run the regions of interest once found. In addition, with native program execution, starting hardware performance counting exactly at the point of interest can be difficult. While the task may be easier with program analysis tools and simulators, given the run-to-run variation in program execution, especially for multi-threaded programs, a region of interest found in an earlier run may not always be reachable in a subsequent execution.

刻画workload的特征，是理解计算机系统行为的过程。刻画特征可以对整个系统或单个程序进行。典型的刻画特征方法包括，使用硬件性能计数器，用工具进行程序插桩，比如Pin，和性能仿真。这些方法会带来不同的代价，这与它们提供的细节程度有关。由于整个程序运行的细节分析，会非常昂贵，多数方法使用采样技术以聚焦在关键的感兴趣区域。基于状态的采样技术，比如SimPoint，可以非常有效的找到有代表性的区域，进行架构仿真。但是，找到感兴趣区域会非常耗时，在研究者中共享这种区域会很好，这样生成感兴趣区域的代码就可以均摊。一个挑战是，一旦找到感兴趣区域后，怎样重新运行这些区域。此外，在本地程序执行中，在感兴趣点精确的开始硬件性能计数，是很困难的。这个任务对于程序分析工具和仿真器是较为简单的，但是在给定程序运行中不同运行的变化，在之前的运行发现的一个感兴趣区域，在后续的运行中并不一定是可达到的，尤其是对于多线程程序。

The PinPoints toolkit from Intel [8] automates the tedious task of profiling an x86 application, finding phases, and creating a checkpoint called a pinball for each representative region. These checkpoints are self-contained and can be shared among researchers easily. In fact, researchers have made SPEC CPU2006 and CPU2017 pinballs [9], [10] publicly available. However, pinballs only work with Pin-based simulators and analysis tools. There is a need for a sharing mechanism that is not dependant on Pin. We believe that having regions of interest represented as x86 binaries is one possible solution.

Intel的PinPoint工具集将profiling x86应用、寻找状态、对每个有代表性的区域创建checkpoint的乏味任务自动化了，这个checkpoint也称为pinball。这些checkpoints是自包含的，可以很容易的在研究者之间共享。实际上，研究者已经制作了SPEC CPU2006和CPU 2017的pinballs进行公开。但是，pinballs只在基于Pin的仿真器和分析工具上可以工作。需要一种不依赖于Pin的共享机制。我们相信，使感兴趣的区域表示为x86 binaries是一种可能的解决方案。

To accomplish this, we present a set of tools for precisely capturing interesting program regions in the form of standalone executables called ELFies. An ELFie is an executable in the Executable and Linkable format, ELF [11], capturing a portion of another program’s execution. ELFies themselves are statically linked binaries and can be generated from executions of other statically or dynamically linked, single or multithreaded, x86 binaries (32 or 64-bit). They can be fed to any characterization tool that accepts ELF binaries. No changes to the characterization tools are required as ELFies behave like regular program executables for all practical purposes. Further, ELFies are easier to share among researchers than the original applications and they will start executing exactly at the point in the original application execution that was captured.

为此，我们提出了一个工具集，可以精确的捕获感兴趣程序区域，形式为独立的可执行程序，称为ELFies。一个ELFie是ELF格式的可执行程序，捕获了另一个程序执行的一部分。ELFies本身是静态链接的binaries，可以从其他静态或动态链接的，单线程或多线程的，x86 binaries（32或64 bit）的执行中生成出来。可以送入任何刻画特征的工具中，像ELF binaries一样作为输入。不需要对刻画特征工具进行任何改变，因为ELFies就像常规程序执行一样。而且，ELFies比原始应用更容易在研究者之间共享，可以在原始应用执行捕获的地方，严格的开始执行。

Our approach is based on the Pin-based framework for program capture and deterministic replay called PinPlay [12]. We used the publicly available version of the PinPlay toolkit [13], with the ability to generate fat pinballs (see Subsection II-A). The overall approach for ELFie generation is shown in Figure 1. We run the test program under the PinPlay logger tool providing it a specification for the region of interest, selected for instance by program phase analysis. The logger captures the specified portion of the program execution in a set of files collectively called a pinball. The pinball contains, among other things, a memory image (a .text file common to all threads), and the architectural register values at the beginning of the region (one .reg file per thread, which also includes register changes from system calls and signals). Next, our pinball2elf tool reads a pinball and generates an ELF binary by translating the pinball memory image pages to ELF sections and adding a startup code section at the entry address. The startup code creates the required number of threads, initializes each thread’s architectural registers, and jumps to the beginning of the actual program code inherited from the original pinball. Other data in the pinball that is needed for constrained execution, like the details for injection of system call side-effects and the enforcement of shared memory access order of various threads, are ignored during this conversion.

我们的方法是基于Pin的框架PinPlay，进行程序捕获和确定性的重演。我们使用公开可用的PinPlay工具集版本，可以生成胖pinballs（见2.1）。ELFie生成的总体方法如图1所示。我们在PinPlay logger工具下运行测试程序，为感兴趣区域提供了指标，可以由程序状态分析选择。logger将程序执行的指定部分捕获到一系列文件中，称为pinball，其中包含内存镜像（对所有线程都常见的.text文件），在区域开始处的架构寄存器值（每个线程都有一个.reg文件，这还包括寄存器从系统调用和信号的变化）。下一步我们的pinball2elf工具读取一个pinball，将pinball内存镜像页面翻译到ELF节，在entry地址处加上一个起始代码节。起始代码创建需要的线程数量，初始化每个线程的架构寄存器，跳转到从原始pinball中继承的实际程序代码的起始处。pinball中的其他数据，是约束执行所需要的，比如注入到系统调用副作用和安排多个线程的共享内存访问顺序的细节，在本文中则被忽略了。

Checkpoint/restore in user space (CRIU) [14] is a Linux tool that allows one to capture the state of a process tree to disk and to restore it later on the same or similar machine. It supports multiple usage scenarios including process migration and the debugging and analysis of applications. With ELFies, we focus on regions-of-interest from a single-process, multi-threaded application for targeted analysis. A CRIU checkpoint is a snapshot at a particular point in the execution with no specified end. ELFies represent a bounded region in the execution as captured in the corresponding pinball. ELFies are Linux binaries and hence can be run by themselves and can be used with tools that run with binaries. Since pinballs can be generated on operating systems other than Linux, one can imagine tools similar to pinball2elf that convert pinballs to other executable formats such as Portable Executable (PE) format on Windows and Mach-O on MacOS.

用户空间的checkpoint/restore是一个Linux工具，可以将一个进程树的状态，捕获到磁盘，后面在相同或类似的机器上进行恢复。它支持多种用途的场景，包括进程迁移，应用的调试和分析。有了ELFies，我们聚焦在一个单进程，多线程应用的感兴趣区域的目标分析中。一个CRIU checkpoint是运行中一个特定点的快照，没有指定的结束。ELFies表示执行中一个约束的区域，在对应的pinball中捕获。ELFies是Linux binaries，因此可以自己运行，可以在运行binaries的工具中使用。由于pinballs可以在Linux以外的其他操作系统中生成，可以想象，肯定有类似于pinball2elf的工具，可以将pinballs转换到其他可执行格式，比如Windows中的PE格式，和MacOS中的Mach-O格式。

Table I compares ELFies, the target of this work, with pinballs. ELFies can be run natively and without any extra overhead. They can be run with any tool that otherwise accepts an ELF executable—no modifications to the tool are necessary. This flexibility allows ELFies to be used for a variety of purposes. However, since pinball2elf only uses the initial memory and register state from a pinball to create an ELFie ignoring the rest of the files required for enforcing determinism, an ELFie run is non-deterministic. Also, pinball2elf currently does not add any debug information to ELFies hence they do not support symbolic debugging.

表I比较了本文中的目标ELFies和pinballs。ELFies可以在本地运行，没有任何其他成本。接受ELF格式的可执行文件的工具，都可以运行ELFie，不需要对工具进行修改。这种灵活性使ELFies可以用作很多用途。但是，由于pinball2elf只使用pinball中的初始内存和寄存器状态，来创建ELFie，忽略了其他的确保确定性需要的文件，所以ELFie运行并不是确定性的。而且，pinball2elf目前并不向ELFies加入任何调试信息，因此并不支持符号调试。

Two questions relevant for the use of ELFies are (1) How will system calls behave? and (2) How will an ELFie run end? ELFies使用相关的两个问题是：(1)系统调用的行为是怎样的？(2)ELFie运行怎样结束？

### 1.1. The System Call Handling Challenge

During a pinball replay, most system calls are skipped, and their register results are injected from the .reg files. Program memory, changed by system calls, is inserted at use time based on automatically logged values [15]. This guarantees that the results of non-repeatable system calls such as gettimeofday() will be the same during replay as was during logging. ELFies do not have any injection mechanism to handle system calls—they are simply re-executed natively. So, at times, some control-flow decisions based on system call results may cause ELFie execution to go on a different path compared to a pinball replay. Also, some system calls may rely on OS resources such as open file descriptors which will not be available during an ELFie run and will fail. For example, consider a file opened before a region of interest and used in the region. The region pinball replay will skip the file read and return the stored results, however an ELFie will try to repeat the file read system call and fail. Luckily, the constrained replay of the parent pinball acts as a reference for an ELFie execution in terms of the system calls it will execute and files it will access. We can use this information to guide ELFie execution in many cases. In fact, we have developed a SYSSTATE technique to ensure correct re-execution with file-related and other common Linux system calls. In particular, a Pin-tool re-constructs the file and heap state with replay-based analysis for the test pinball and stores it in a sysstate directory. pinball2elf embeds references to the sysstate contents in the startup code of the ELFie created from the pinball.

在一个pinball replay中，多数系统调用都跳过了，它们的寄存器结果从.reg文件注入。系统调用改变的程序内存，在使用时基于自动logged值插入。这确保了不可重复的系统调用，如gettimeofday()的结果，在replay的时候会和logging的时候一样。ELFies没有任何注入机制来处理系统调用，它们只是在本地重新执行。所以，有时候，一些基于系统调用结果的控制流决策，与pinball replay相比，会使ELFie执行进入到不同的路径中。同时，一些系统调用会依赖于OS资源，比如打开文件的descriptors，这在ELFie运行的时候会不可用，所以会失败。比如，考虑在感兴趣区域之前就打开了文件，然后在这个区域中进行了使用。区域pinball replay会跳过文件读取过程，返回存储的结果，但是ELFie会尝试重复文件读取的系统调用，然后失败。幸运的是，父辈pinball的约束replay，会作为ELFie执行在要执行的系统调用和要访问的文件上的一个参考。我们可以使用这些信息在很多情况下来引导ELFie执行。实际上，我们提出了一种SYSSTATE技术，在与文件有关的和其他常见的Linux系统调用中，确保正确的重新执行。具体的，一个Pin工具，用基于replay的分析，重建了文件和heap状态，以测试pinball，将其保存在sysstate文件夹中。pinball2elf将参考嵌入到sysstate内容中，在从pinball中创建的ELFie的起始代码中。

### 1.2. The Graceful Exit Challenge

ELFies contain only the memory (data + text) pages captured in the pinball. If the execution of an ELFie goes on a new path, it may try to access/execute a page that has not been captured, resulting in an ungraceful exit. On the other hand, while a pinball replay will always terminate after the desired number of instructions (recorded in the pinball), at times an ELFie may continue to execute far beyond the desired number of instructions—as long as it stays within the captured memory range. We support graceful exit of ELFies using hardware performance counters. Pinball2elf can program a hardware counter, one per thread, to count retired instructions and create a callback to exit each thread on reaching the expected instruction count for the region of interest captured in the incoming pinball. If an ELFie is used by some other program, such as a simulator, the graceful exit of ELFie can be ensured by that program instead.

ELFies只包含在pinball中捕获的内存页面（数据+文本）。如果ELFie的执行走了新的路径，那么就可能尝试访问/执行一个没有捕获的页面，导致异常的退出。另一方面，一个pinball replay在一定数量的指令之后（在pinball中记录的）总会停止的，有时候，ELFie会在超过期望数量的指令后，会继续执行，只要其继续留在捕获的内存范围内。我们使用硬件性能计数器，支持ELFies的正常退出。Pinball2elf会对硬件计数器进行编程，每个线程一个，以对退休的指令进行计数，创建一个回调函数，在达到期望的指令数量（pinball中捕获的感兴趣区域中的数量）后，退出每个线程。如果其他一些程序使用了一个ELFie，比如一个仿真器，那么ELFie的正常退出，会由这个程序确保。

Despite the two challenges above, we found ELFies to be quite suitable for use cases such as native performance measurement or tool-based analysis and simulation for regions of interest. For instance, verifying the quality of simulation region selection requires running both the whole-program and all selected regions using the same methodology, yet whole-program simulation is prohibitively expensive. ELFies allow us to perform the evaluation using native runs instead, thus enabling accurate representative generation of extremely long-running programs (see Section IV-A). A graceful exit can be forced by analysis tools after the desired number of instructions. The effect of system calls can be minimized by choosing the regions appropriately. If an ELFie run fails consistently before reaching the desired instruction count, starting with an alternative region of interest may help. In our experiments we used alternate region selection (i.e., the second or third best representative for a given phase/cluster that SimPoint provides), to increase coverage (the sum of the weights of correctly executing ELFies) up to 90%+ in most cases, while still maintaining high accuracy. Without any guarantee of repeatability or a graceful exit, other more general uses of ELFies may not be possible. In those cases, pinballs with their constrained replay guarantee may be more appropriate.

尽管有上面两个挑战，我们发现ELFies非常适合于本地性能度量，或基于工具的分析，和感兴趣区域的仿真。比如，验证仿真区域选择的质量，需要使用相同的方法运行整个程序和所有选定的区域，但是全程序仿真是非常昂贵的。ELFies使我们可以用本地运行来进行评估，因此使运行极长的程序的准确的有代表性的生成成为可能。在期望的指令数量后，由分析工具进行强迫的正常退出。系统调用的效果，可以通过合理的选择区域，进行最小化。如果ELFie运行在达到期望的指令数量之前持续失败，那么可能需要从另一个感兴趣区域开始。在我们的试验中，我们使用替代的区域选择（即，对于SimPoint给出的状态/聚类，第二好或第三好的代表），以增加覆盖率，在多数情况中达到90%+（正确执行ELFies的权重的和），而仍然保持高准确率。在不保证可重复性或正常退出的情况下，ELFies的其他更一般性的使用就不可能。在这些情况中，带有约束replay保证的pinball，可能更为合适。

In this paper, we present details of how the pinball2elf tool works and how we are using the ELFies it generates for focused analysis of regions of interest of long-running applications. Our main contributions are as follows:

在本文中，我们给出pinball2elf工具具体怎样工作，以及我们怎样使用其生成的ELFies，聚焦分析长期运行应用的感兴趣区域的细节。我们的主要贡献如下所示：

1) We describe the tool-chain (PinPlay + pinball2elf) for converting user-level checkpoints (pinballs) to executables (ELFies) as shown in Figure 1. To our knowledge, the idea of creating a stand-alone executable for an arbitrary portion of a multi-threaded x86 program execution is novel.

我们描述了将用户级checkpoints (pinballs)转换到可执行文件(ELFies)的工具链(PinPlay+pinball2elf)，如图1所示。据我们所知，对多线程x86程序执行的任意部分，创建一个独立可执行文件，这个思想是新的。

2) We show the use of ELFies, among other things, for validating simulation region selection techniques. Traditionally, the validation is done using simulation and hence is very slow. With ELFie-based validation, we use native hardware instead of simulators which allows for validation of really long-running programs.

我们展示了ELFies在验证仿真区域选择技术中的使用。传统上来说，验证的进行是使用仿真的，因此非常慢。采用基于ELFie的验证，我们使用本地硬件，而不是仿真器，这可以对非常长期运行的程序进行验证。

Pinballs have provided a way to share regions of interest among researchers [9], [10]. We hope ELFies can play a similar role for x86-binary-based tools/simulators. We have open-sourced pinball2elf tool to facilitate that [16].

Pinball给出了一种在研究者中共享感兴趣区域的方法。我们希望ELFies可以对基于x86 binary的工具/仿真器扮演类似的角色。我们将pinball2elf工具进行了开源。

The rest of this paper is organized as follows. Section II describes the implementation of the pinball2elf tool. Section III is about typical applications of ELFies. Section IV presents some case studies showcasing advantages of using ELFies for performance analysis and simulation. Section V summarizes other work in this area and section VI concludes.

本文的其他部分组织如下。第2部分描述了pinball2elf工具的实现。第3部分是关于ELFies的典型应用。第4部分给出了一些案例研究，展示了使用ELFies进行性能分析和仿真的优势。第5部分总结了本领域的其他工作，第6部分给出了我们的结论。

## 2. Implemenation

This section presents an overview of the changes made to PinPlay and details of the pinball2elf tool. 本节给出了对PinPlay进行的修改概览，和pinball2elf工具的细节。

### 2.1. PinPlay Changes

The motivation for creating an ELFie is that it should always start with the program state captured at the beginning of a region of interest but should then run in an un-restricted manner, without any enforcement of determinism, using any memory it requires. A pinball, on the other hand, is designed for constrained replay and hence captures only the memory pages that were actually used in the logging run. An unrestricted ELFie run could, at times, diverge from the recorded control flow, try to access an un-captured memory page, and fail. To alleviate this problem, we requested the PinPlay team to make a few changes to the PinPlay logger. First, a new switch, -log:whole_image, was added that records all the loaded sections, including global static data, for the test image. Second, since the logger by default creates text/data page injection records lazily, another switch, -log:pages_early, was added, which puts the pages in the initial memory image (the .text file). The two new switches can be combined with a single switch -log:fat. We call the resulting pinball a fat pinball. All the pinballs we generated for ELFie evaluation were fat pinballs. Depending on the number and sizes of shared libraries used by a program, a fat pinball can be much larger than a regular pinball. Finally, a new replay switch, -replay:injection, was added, which when set to zero, attempts replay without any system-call side-effect injection or enforcement of thread order. Such injection-less replay mimics the execution of an ELFie (while still running under Pin) and hence is useful in debugging ELFie failures.

创建ELFie的动机是，程序状态的开始应当是感兴趣区域捕获的开始，但是运行应当在不受限制的状态中，不能限制其确定性，使用其需要的任何内存。另一方面，pinball的设计是用于约束replay，因此捕获的内存页，实际上在logging run中使用。无约束的ELFie运行可以有时候从记录的控制中偏移，试图访问未捕获的内存页面，并运行失败。为缓解这个问题，我们请求PinPlay团队对PinPlay logger进行了几个修改。第一，加入了一个新的switch，-log:whole_image，记录了所有载入的节，包括对于测试镜像的全局静态数据。第二，由于默认的logger以懒的方式创建的text/data页注入记录，加入了另一个switch，-log:pages_early，将页面放入到初始的内存镜像中（.text文件）。这两个新的switch可以与-log:fat结合使用。我们称得到的pinball为fat pinball。我们为ELFie评估所生成的所有pinballs都是fat pinballs。一个程序使用的共享库的数量和大小不同，一个fat pinball会比常规pinball大很多。最后，还加入了一个新的replay switch，-replay:injection，当设为零时，会尝试在没有任何系统调用副作用注入，或附加线程顺序时，进行replay。这种无注入的replay模拟ELFie的执行（仍然在Pin中运行），因此在调试ELFie失败时是有用的。

A fat pinball for a region has all the memory used inside the region pre-loaded in the initial memory image file. This includes text/data pages from any libraries dynamically loaded inside the region and any heap pages accessed inside the region. However, heap pages that are allocated but not accessed are not included in the initial memory image.

一个区域的fat pinball将这个区域使用的所有内存预载入到初始内存镜像文件中。这包括任何动态载入到这个区域中的库，和访问这个区域中的任何heap页面的text/data页面。但是，已经分配但并未访问的heap页，并没有包括在初始memory页面中。

### 2.2. The Pinball2elf Tool

Pinball2elf is a tool to create executable or object files from pinballs. The executables generated by pinball2elf are statically linked and hence are self-contained without any dependence on shared libraries. During execution, an ELFie has the same memory layout as the original pinball, i.e., all memory regions are mapped to the same addresses as during the pinball recording run. That makes ELFies useful for memory-characterization studies.

Pinball2elf是一个工具，从pinball中创建可执行程序或目标文件。pinball2elf生成的可执行程序是静态链接的，因此是自包含的，不依赖于其他共享库。在执行的过程中，ELFie与原始的pinball的内存布置是一样的，即，所有内存区域映射到pinball记录运行时的相同地址。这使ELFies在内存特征刻画研究中很有用。

1) Overview of the ELF Format: The Executable and Linkable Format (ELF) [11] is a standard, flexible, and extensible format for representing binary code in a system. ELF is used for object files, executables, shared libraries, core dumps, and kernel modules. An ELF file usually consists of an ELF header followed by other headers describing the file layout and of sections or segments containing data. Depending on the type, an ELF file can include a program header table and a section header table. A typical layout of object and executable ELF files is illustrated in Figure 2. The ELF header must be located at the beginning of the file and is used to locate other parts of the file. This structure defines sizes and file offsets of the section header and program header tables, specifies the virtual address of the program entry point, and stores other useful information.

ELF格式概览：ELF是一种标准、灵活、可拓展的格式，表示系统中的二进制代码。ELF用于目标文件，可执行文件，共享库，core dumps和kernel模块。一个ELF文件通常包含一个ELF头，然后是其他头，描述了文件布局，然后是节或者段，包含了数据。按照类型不同，一个ELF文件可以包含一个程序头表和一个节头表。一个典型的目标和可执行ELF文件的布局如图2所示。ELF头在文件最开始的地方，用于定位文件的其他部分。这个结构定义了节头和程序头表的大小和文件偏移，指定了程序入口点的虚拟地址，存储了其他有用的信息。

The section header table is an array of section-header structures, each of which describes a section. A section header structure defines the file offset of each section, its type and size, its attributes (allocatable, executable, and writable), and its virtual address (if allocatable, i.e., if it will appear in the memory image of the process for the executable). Some sections in an ELF file have pre-defined meanings and hold program data or are used by the system loader. For example, .text holds executable instructions of a program, .data holds initialized data, and .symtab contains information needed to locate a program’s symbolic definitions and references.

节头表是节头结构的阵列，每个描述了一个节。节头结构定义了每个节的文件offset，其类型和大小，其属性(allocatable, executable, and writable)，其虚拟地址。ELF文件中的一些节有预定义的意义，保持程序数据，或由系统loader使用。比如，.text保存的是程序的可执行指令，.data保存的初始化的数据，.symtab包含的是定义程序的符号定义和参考的信息。

2) Pinball to ELF Mapping: We chose to make ELFies statically linked because a statically-linked executable contains a set of object files and libraries which are bound at link-time with all references resolved and hence is completely self-contained. A fat pinball’s .text file holds the memory dump of the captured program region (all pages mapped into the memory). The .reg files contain initial register contents of program threads at the beginning of the region. Each region from the .text file which consists of consecutive pages is represented with a section in the ELF file with the virtual address set to the virtual address of the start page of the region. Thread register contents are packed and written into a separate data section with the virtual address mapping to some memory range that is not used by the pinball. The resulting ELF object is then statically linked with a startup code that creates the required number of threads and initializes the thread contexts from the ELF file. The layout of such an executable is shown in Figure 3.

Pinball到ELF的映射：我们选择让ELFies是静态链接的，因为静态链接的可执行文件包含了目标文件和库的集合，在链接时是与所有解析的参考是有关联的，因此是完全自包含的。一个fat pinball的.text文件，包含了捕获的程序区域的memory dump（所有映射到内存的页面）。.reg文件包含了程序线程在区域开始处的初始的寄存器内容。.text文件中每个区域，包含了连续的页面，都用ELF文件中的一个节来表示，虚拟地址设置为区域的起始页的虚拟地址。线程寄存器内容打包写入单独的数据节中，虚拟地址映射到pinball没有使用的一些内存范围中。得到的ELF静态链接到起始代码上，创建需要数量的线程，从ELF文件中初始化线程上下文。这样一个可执行文件的布局如图3所示。

3) Stack Collision: An ELFie generated from a fat pinball contains all the memory pages that were mapped into the memory of the traced process and includes code and data from the program binary, code and data from shared objects, and the program stack. When an ELFie is run natively, the system ELF loader first parses the ELFie file, maps its various program segments into memory, sets up the entry point, and finally initializes the stack for the ELFie process. The stack is populated in the normal way to contain command line arguments, auxiliary vectors, and arrays of pointers to environment variables of the process. However, the ELFie binary already has the stack pages from the pinball which may overlap with the address range of the new stack—which the loader is trying to reserve for the ELFie process. Even though the bottom of the stack can vary slightly from process to process, because of Linux’s stack randomization feature, there is a possibility that the virtual addresses of the two stack regions, one requested by the loader and the other mapped from pinball, intersect. If such a collision happens, the loader will be able to reserve only a very small amount of the memory for the new stack which can be insufficient to pass the environment, program arguments, etc. In this case the process will be killed before any ELFie code is executed. Figure 4 illustrates the stack-collision problem.

从fat pinball中生成的ELFie，包含了所有的内存页面，映射到了跟踪进程的内存中，包含程序binary的代码和数据，共享目标的代码和数据，和程序stack。当本地运行一个ELFie，系统ELF loader首先解析ELFie文件，将其程序段映射到内存中，设置好入口点，最后为ELFie进程初始化stack。stack以正常方式进行populate，以包含命令行参数，辅助向量，和指向进程环境变量的指针阵列。但是，ELFie binary已经有了从pinball中的stack页面，这可能与新的stack的地址范围重叠，loader正尝试为ELFie进程保存。虽然stack的底部会随着进程的不同略有不同，因为Linux有stack随机化的特征，有一种可能性，两个stack区域的虚拟地址，一个是loader要求的，另一个是pinball映射的，会有交叠。如果发生了这样的冲突，loader要能够为新的stack保存很少内存，这不足以传递环境，程序参数，等。在这种情况下，在执行任何ELFie代码前，进程会被kill掉。图4展示了stack冲突问题。

Fortunately, the stack-collision problem can be solved. The sections in an ELFie corresponding to the stack from the parent pinball can be marked as non-allocable, which prevents the ELF loader from mapping them into memory during process initialization and lets the loader allocate the stack for the new process freely. At the very beginning of ELFie startup code, the pages of the newly created stack colliding with the stack from the parent pinball are unmapped, and replaced with pages from ELFie segments containing the pinball stack. The code performing such remapping requires only a few system calls: open()/close() to open and close the ELFie being executed and unmap()/map() to perform remapping. The essential part of the remapping is a simple loop iterating over the array of addresses of pages to be remapped and successively unmapping and mapping corresponding pages. It is safe to unmap the stack of the new process since the startup code does not touch the stack allocated by the ELF loader. Figure 5 shows the code implementing such a procedure. Note that the remapping can be done safely for all pages from the pinball (and not just the stack pages) which is the most portable way.

幸运的是，stack冲突问题可以解决。ELFie中的节，对应着pinball中的stack的那些，可以标记为non-allocable，防止ELF loader在线程初始化的时候，将它们映射到内存中，让loader为新进程自由分配stack。在ELFie起始代码的开始处，新创建的stack的页面，与父pinball的stack冲突的那部分，是未映射的，替换为包含pinball stack的ELFie段的页面。进行这样的重映射的代码，只需要几个系统调用：open()/close()来打开关闭要执行的ELFie，unmap()/map()以进行重映射。重映射的关键部分，是一个简单的循环，在要进行重映射的页面地址阵列上迭代，不断的unmap和map对应的页面。对新进程的stack进行unmap是安全的，因为起始代码并没有接触ELF loader分配的stack。图5展示了实现这个过程的代码。注意，对于pinball来的所有页面，都可以安全的进行remap，这是最可移植的方式。

4) Thread Creation and Initialization: The rest of the startup code creates threads and initializes their contexts. Creation of threads is performed in a small loop that uses the clone() system call. It passes a pointer to the thread context data as the stack pointer of the thread being created and a pointer to the code loading the context (thread initialization function) as the thread function.

线程创建和初始化：起始代码的剩余部分，创建线程，初始化其上下文。线程创建在一个小循环中进行，使用clone()的系统调用。它传递给线程上下文数据一个指针，作为要创建的线程的stack指针，还有一个指针给载入上下文的代码（线程初始化函数），作为线程函数。

The context structure fully matches a thread’s initial register state from the parent pinball and has two parts. The first part includes the X87/MMX, SSE, AVX, AVX-512, MPX, and other extended states. The layout of this part is the same as the FXSAVE/XSAVE area defined in the Intel Software Developers Manual [17]. This part of the context can be loaded either using the FXRSTOR or the XRSTOR instruction, depending on the CPU micro-architecture of the pinball. The second context structure part contains values of segment selectors (FS and GS bases), the flag register, and the general purpose registers (GPRs). The thread-initialization function receives these registers on the stack, and it pops and sets the flag and the GPRs. At the bottom of the thread-initialization function stack resides the pointer to a small piece of code which is called the thread entry. It sets up the stack pointer of the thread to the ‘real’ value and jumps to the thread’s ‘real’ code. There are as many thread entries as there are threads in the parent pinball, one for each thread. Figure 6 shows an example of the thread entry. Note that the ELFie startup code only creates those threads that were created before the program region starts. New threads may still be created by the application itself during execution of the region, through the clone system call as normal.

上下文结构完全匹配线程的初始寄存器状态，包含两个部分。第一部分包含X87/MMX, SSE, AVX, AVX-512, MPX和其他拓展的状态。这个部分的布局与FXSAVE/XSAVE区域相同，在Intel软件开发者手册中定义。这部分上下文可以用FXRSTOR或XRSTOR指令载入，依赖于pinball的CPU微架构。第二个上下文结构部分包含的段选择器的值(GS and GS bases)，flag寄存器，和general purpose寄存器(GPRs)。线程初始化函数在stack上接收这些寄存器，弹出并设置flag和GPRs。在线程初始化函数stack的底部，是一个指针，指向一小段代码，称为线程entry。它设置了线程的stack指针，指向真值，跳转到线程的真代码。有很多线程entries，因为在父pinball中有多个线程，每个线程一个。图6展示了线程entry的一个例子。注意，ELFie起始代码只创建那些在程序区域开始之前，就已经创建过的线程。新的线程仍然可以由应用自己在运行这个区域的时候创建，但是是通过clone系统调用按照正常方式创建的。

5) Other Pinball2elf Features: The ideas described above are implemented in the pinball2elf tool. The tool can generate both ELF object files (without any startup code) and statically linked ELF executables (with startup code) from single and multi-threaded pinballs. Additionally, pinball2elf allows users to link in extra code to be called at the beginning of each thread entry. It creates a linker script which gives users explicit control over the process of linking an ELFie object file with an object file containing user’s extra code. The linker script contains the parent pinball memory layout, which is preserved in the resulting linked executable. Pinball2elf can also dump initial thread contexts in the form of assembly listing which can help users to write their own startup code. For ELFie debugging purposes, pinball2elf inserts symbols for all functions from the startup code, symbols for most of the elements of thread initial states in a format .t< N>.< object> (for example .t0.rax, .t0.xmm or .t0.ext_area2), and symbols pointing to the start of each thread.

其他pinball2elf特征：上面描述的思想在pinball2elf工具中实现。这个工具可以从单线程和多线程pinball中，生成ELF目标文件（没有起始代码）和静态链接的ELF可执行文件（有起始代码）。另外，pinball2elf使用户可以在每个线程entry可以链接入额外要调用的代码。它创建了一个链接脚本，使用户可以显式的控制将一个ELFie目标文件，与一个包含用户的额外代码的目标文件，进行链接的过程。链接脚本包含父pinball的内存布局，这保存在得到的链接后的可执行文件中。pinball2elf还可以dump初始的线程上下文，成为汇编代码列表，可以帮助用户写其自己的起始代码。对于ELFie调试的目的，pinball2elf对所有从起始代码中的函数插入符号，这是对线程初始状态的元素的多数符号，格式为.t< N>.< object>，比如.t0.rax, .t0.xmm 或 .t0.ext_area2，和指向每个线程开始的符号。

Callback Support: Pinball2elf allows users to add calls to functions of their choice at two points early in ELFie execution:

回调支持：pinball2elf使用户可以在ELFie执行早期的两个点上增加对函数的调用：

1) -p elfie_on_start() after start-up but before starting application code execution, 在起始代码之后，但在应用代码执行之前；

2) -t elfie_on_thread_start() just before a thread jumps to user code. 在一个线程跳转到用户代码之前；

These functions can be used to initialize hardware performance counters, for example, for native performance analysis of embedded application region. Another switch, -e elfie_on_exit(), causes a monitor thread to be created first. This thread spawns the main application thread and waits for it to exit. When the main application thread exits, a call to user-defined elfie_on_exit() is made. This function, for example, can be used to output final values of any hardware performance counters that were initialized on ELFie start.

这些函数可以用于初始化硬件性能计数器，比如，用于嵌入式应用区域的本地性能分析。另一个switch，-e elfie_on_exit()，会导致一个监控线程首先创建。这个线程产生主应用线程，等待其退出。当主应用线程退出，调用用户定义的elfie_on_exit()。这个函数可以用于输出任意硬件性能计数器的最终值，该值在ELFie起始的时候初始化。

Marker Support: When an ELFie is used for analysis or simulation, the startup code needs to be skipped. pinball2elf can add special ‘marker’ instructions at the beginning of application code using the switch --roi-start [TYPE:]TAG where type can be one of sniper, ssc, or simics respectively for Sniper [3], Pintools [18], and Simics [19].

Marker支持：当ELFie用于分析或仿真，需要跳过起始代码。pinball2elf可以在应用代码的开始处加入特殊的marker指令，使用switch -roi-start [TYPE:]TAG，其中type对Sniper，Pintools和Simics可以是sniper，ssc或simics。

Creating Custom ELFies: Depending on the intended application (performance analysis or simulation), users can add the right callback routines and markers. The pinball2elf distribution has wrapper scripts with the sources for the required callback routines for common use cases. The execution flow of a typical custom ELFie is shown in Figure 7.

创建定制的ELFies：依据想要的应用（性能分析，或仿真），用户可以加入正确的回调程序和markers。pinball2elf有wrapper scripts，有对常见使用情况的需要的回掉程序。一个典型的定制ELFie的执行流如图7所示。

Debugging ELFies: The pages inside an ELFie containing application code are marked as not loadable hence tools, such as the GNU debugger (gdb), can not ‘see’ application pages inside an ELFie right away after the initial loading of an ELFie. For setting breakpoints at an application instruction, the suggested way is to first break on elfie_on_start() at which point all application pages are guaranteed to be in memory and then set a breakpoint at the desired application address(hex). Symbolic debugging of application code is currently not supported with ELFies although pinball2elf can be extended to add application debug information for symbolic debugging. ELFie generation scripts make sure debug information does exist for ELFie callback routines hence they can be debugged symbolically. For debugging multithreaded ELFies with gdb, first doing a set detach-on-fork off followed by break elfie_on_thread_start and using info inferior and inferior N commands works well.

调试ELFies：ELFie中的页面，那些包含应用代码的，被标记为不能loadable，因此像GNU debugger (gdb)这样的工具，不能在初始载入ELFie之后看到ELFie内部的应用页面。对于在一个应用指令处设置断点，建议的方式是，首先在elfie_on_start()处断点，在这个点上所有应用页面都保证在内存中，然后设置一个断点在期望的应用地址中。应用代码的符号调试当前在ELFies中并不支持，虽然pinball2elf可以拓展，为符号调试加入应用调试信息。ELFie生成的脚本确保了对ELFie回掉程序来说是存在调试信息的，因此可以进行符号调试。用gbd调试多线程ELFies，首先进行一个集合detach-on-fork off，然后是在break elfie_on_thread_start，使用info inferior和inferior N命令效果良好。

### 2.3. ELFie Execution Challenges

As outlined earlier, there are two main challenges in ELFie execution. 之前指出，在ELFie执行中有两个主要挑战。

1) The Graceful Exit Challenge: Figure 7 shows a typical ELFie execution flow. Once an ELFie thread starts executing application code, it can continue going, until it encounters an exit() or exit_group() system call. However, since an ELFie only represents a region of execution, it has data and text pages only to support that region. If an ELFie execution diverges from the captured execution or goes past the captured region, it might access a text or data page not present in memory and exit ungracefully. Therefore, we need a way to stop ELFie execution after the captured region ends. If a custom ELFie is being used by some dynamic analysis tool or a simulator, they can end ELFie execution explicitly using some region ending criterion (typically the instruction count recorded in the corresponding pinball). For ending a stand-alone execution of an ELFie, pinball2elf provides support for custom callback routines to program hardware performance counters for ending ELFie execution after the desired number of instructions (as recorded in the pinball) are executed (retired).

图7展示了一个典型的ELFie执行过程。一旦一个ELFie线程开始执行应用代码，就可以持续进行，直到遇到exit()或exit_group()的系统调用。但是，由于ELFie只代表了一个执行区域，所以就只有支撑这个区域的data和text页面。如果一个ELFie执行与捕获的执行有偏离，或超过了捕获的区域，就可能访问不在内存中存在的text或data页面，然后异常退出。因此，我们需要一种方法，在捕获的区域结束后，停止ELFie执行。如果一些动态分析工具或仿真器使用了一个定制的ELFie，可以显式的结束ELFie的执行，使用一些区域结束的规则（一般是在对应的pinball中记录的指令数）。对于结束ELFie的独立执行，pinball2elf对定制回掉函数提供了支持，当程序硬件性能计数器达到一定数值时，在达到期望的指令数量时，结束ELFie的执行。

2) The System Call Handling Challenge: Unlike pinballs, ELFies do not have any injection mechanism to handle system calls—they are simply re-executed natively. Many system calls, such as gettimeofday() can be safely re-executed. However some system calls that rely on operating system resources, e.g., read() from an open file descriptor need special handling. Capturing all the operating system state in a checkpoint, as done by the CRIU infrastructure [14], can be quite a daunting task. Luckily, since ELFies only need to execute the captured region correctly, we know which system calls occur in the region (from pinball analysis) and need to handle them correctly. Based on our experience with mostly user-level programs (which are a good match for Pin-based analysis anyway), we found two classes of system calls that need handling: (1) file-related system calls such as open(), lseek() and (2) heap memory handling system call brk. We have developed a Pintool, pinball_sysstate that looks at system calls in a pinball and extracts file-related state and puts it in a pinball.sysstate directory. Figure 8 shows an example output from the pinball_sysstate tool. Files that are opened inside the pinball region get a proxy version created with the right name and it is populated solely based on the relevant read() system calls in the region. File opened prior to the region, and hence only referred via a file descriptor, have a proxy file with a dummy name FD_n, where n is the relevant file descriptor. The pinball2elf toolkit provides a generic elfie_on_start() callback that preopens any FD_n files in the sysstate directory and assigns them the right file-descriptor using the dup() system call. An ELFie is supposed to be executed in the sysstate/workdir directory created by the pinball_sysstate tool. Files that were opened using an absolute path-name during the pinball region, are copied to their rightful location (alternatively, the Linux command chroot, with the sysstate directory as the special root, can be used to execute the ELFie). The same Pintool, pinball_sysstate, also outputs the return values of the first and the last brk() system call in the pinball region in a file called BRK.log. A custom elfie_on_start() callback uses these values to set the memory layout for the ELFie process using the prctl() system call.

系统调用处理的挑战：与pinballs不同，ELFie没有任何注入机制，来处理系统调用，它们只是简单的在本地重复执行。很多系统调用，比如gettimeofday()可以安全的重复执行。但是，一些系统调用要依赖于操作系统的资源，如read()以打开一个文件描述子，需要特殊的处理。将所有操作系统的状态捕获到一个checkpoint，在CRIU中是这样做的，但这是一个很重的工作。幸运的是，由于ELFies只需要正确的执行捕获的区域，我们知道在这个区域中发生了哪些系统调用（从pinball分析中得到），需要正确的进行处理。基于我们对多数用户级程序的经验（可以很好的匹配基于pin的分析），我们发现两类系统调用需要处理：(1)文件相关的系统调用，比如open(), lseek(), 和(2)heap内存处理系统调用brk。我们开发了一个Pintool，pinball_sysstate查看pinball中的系统调用，提取文件相关的状态，将其放入到一个pinball.sysstate文件夹中。图8展示了pinball_sysstate的一个例子输出。在pinball区域中打开的文件会得到一个代理版本，以正确的名字创建，只基于相关的read()系统调用进行populate。在这个区域之前打开的文件，只用一个文件描述器进行参考，有一个代理文件，文件名为FD_n，其中n是相关的文件描述子。pinball2elf工具集提供了一个通用的elfie_on_start()回调函数，预先打开所有在sysstate文件夹中的FD_n文件，为他们指定正确的文件描述子，使用的是dup()系统调用。ELFie的执行，默认就在pinball_sysstate工具创建的sysstate/workdir文件夹中。在pinball区域中，用绝对路径打开的文件，会被拷贝到正确的位置。同样的pintool，pinball_sysstate，还会输出第一个和最后一个brk()系统调用的返回值，到一个文件中，称为BRK.log。一个定制的elfie_on_start()回调函数使用这些值来为ELFie进程设置内存布局，使用prctl()系统调用。

## 3. Applications

In this section we describe the use of ELFies for dynamic analysis, performance analysis, and simulation of regions of interest they represent. 本节中，我们描述了ELFies在动态分析，性能分析和感兴趣区域仿真中的应用。

### 3.1. Dynamic Analysis with Pin

Pin [1] is a popular dynamic instrumentation framework that works with x86 binaries and hence can handle ELFies. However, an ELFie executes some startup code before it jumps to the actual embedded code from the captured region of interest. Therefore, we need a way to skip Pin-based analysis of ELFie startup code. That can be done in multiple ways. Pinball2elf can add special marker instructions (cpuid or a special nop) and the Pintool doing the analysis can start the actual analysis only after reaching the special marker. Pinball2elf can be used to add a special callback function in an ELFie to be called before the application code executes and then Pin-based analyis can begin on seeing this function. Graceful exit of analysis can be achieved using a Pin-based instruction counting mechanism (based on the instruction count of the corresponding pinball) or using the hardware performance counter based exit mentioned in Section I.

Pin是一个流行的动态插桩框架，可以对x86 binaries进行分析，因此可以处理ELFies。但是，ELFie在跳转到实际的嵌入代码时，会执行一些启动代码。因此，我们需要一种方法来跳过基于pin的对ELFie启动代码的分析。这可以以几种方式进行。Pinball2elf可以加入特殊的marker指令(cpuid或一个特殊的nop)，那么Pintool进行分析就可以只在达到这些特殊marker之后再进行。pinball2elf可以用于在ELFie中加入一个特殊的回调函数，在应用代码执行之前进行调用，然后基于pin的分析可以开始查看这个函数。分析的正常退出，可以用基于pin的指令计数机制来得到（基于对应pinball的指令计数），或使用基于硬件性能计数器的退出，这在第1部分提出过。

### 3.2. Native Performance Analysis

ELFie captures a region of interest from an application execution and provides a precise way to focus performance analysis on that region. While Linux utilities like perf stat will work with ELFies, they need a way to avoid measuring the startup code and handling exit gracefully. Pinball2elf features for adding process-wide and per-thread callback functions are useful in this context. Pinball2elf provides a library, libperfle.a, with an API for initializing hardware performance counters. Per-process and per-thread callback functions can be used to program desired hardware performance counters and also to exit each thread gracefully on executing its expected (as listed in the pinball) instruction count. A callback on process exit can also be inserted using pinball2elf which causes a monitor thread to be created that watches the (graceful) exit of the application process and then can output the final values of various performance counters programmed.

ELFie从应用执行中捕获感兴趣区域，提供了一种在这个区域进行性能分析的精确方式。Linux工具如perf stat会对ELFies起作用，它们需要一种方式避免度量启动代码，并处理好正常退出的问题。pinball2elf的特点在于，加入进程宽的，每个线程的回调函数，在这个上下文中是有用的。pinball2elf提供了一个库，libperfle.a，有一个API来初始化硬件性能计数器。每个进程和每个线程的回调函数可用于编程期望的硬件性能计数器，正常的退出每个进程，执行其期望的指令数量。在进程退出时的回调，也可以用pinball2elf进行插入，会导致创建一个监控线程，监视应用进程的正常退出，然后可以输出各种性能计数器的最终值。

### 3.3 Workload Simulation

While a Pin-based simulator, such as Sniper [3], can be modified to work with replay of pinballs, it does require extra work. With ELFies, which are x86 Linux binaries, simulations can be performed for the region of interest without having to modify the simulator. There is still a requirement to be able to skip the startup code during simulation which can be done using special marker instructions or special instruction/callback function addresses as described in Section II-B5.

基于pin的仿真器如Sniper，可以进行修改，以对pinball的replay进行工作，但的确需要额外的工作。但在ELFie上，这是x86 Linux binary，对感兴趣区域仿真的进行，则不需要修改仿真器。但仍然需要在仿真时跳过启动代码，这可以用特殊的marker指令或特殊的指令/回调函数进行。

We have tested ELFies with three different x86 simulators: 我们用三种不同的x86仿真器来测试ELFies：

1) Pin-based multi-core simulator: Sniper [2], [3] is a Pin-based x86 multi-core simulator which works with x86 Linux binaries. It has been modified to include the PinPlay library [13] and hence can simulate pinballs as well. We use Sniper to evaluate the performance of both a set of multi-threaded pinballs and the corresponding ELFies.

基于Pin的多核仿真器：Sniper是一个基于Pin的x86多核仿真器，可以对x86 Linux binary进行工作。已经进行了修改，包含了PinPlay库，因此可以仿真pinball。我们使用Sniper来评估多个多线程pinball和对应的ELFies的性能。

2) SDE and Simics-based x86 simulator: CoreSim is an Intel-internal cycle-accurate x86 many-core simulator. This simulator supports SDE [20] as a front-end (which itself is based on Pin, but adds emulation of future instructions) as well as Simics [19] to enable full-system simulation. Given that CoreSim is an execution-driven simulator, ELFies can run on CoreSim natively just like any Linux executable. We added Simics magic instructions to the ELFies so we can enable the performance model only after the ELFie startup code has been executed.

CoreSim是一个Intel内部的周期准确x86众核仿真器。这个仿真器支持SDE作为一个前端（其本身是基于pin的，但加入了未来指令的仿真），也支持Simics，以支持完整系统仿真。CoreSim是一个执行驱动的仿真器，ELFies可以在CoreSim上本地运行，与任意Linux可执行文件一样。我们向ELFies加入了Simics magic指令，所以只有在ELFie启动代码执行过后，才可以进行性能模型。

3) Binary-driven x86 simulator: gem5 [4] is an open source computer architecture simulator supporting multiple ISAs, including x86. gem5 can simulate a complete system and an OS in Full-System (FS) mode, or user space only programs where system services are provided directly by the simulator in Syscall Emulation (SE) mode. Often, gem5 is used with atomic CPU and fastmem options to collect Basic Block Vectors (BBVs) as input to a sampling methodology such as SimPoint [5]. However, generating pinballs and ELFies is much faster, which is useful for studies that involve frequent recompilation of binaries.

Binary驱动的x86仿真器：gem5是一个开源的计算机架构仿真器，支持多个ISAs，包括x86。Gem5可以仿真一个完整的系统和OS，有FS模式，也有SE模式，即用户空间中。通常，gem5是用atomic CPU使用的，用fastmem选项来收集BBV作为采样方法如SimPoint的输入。但是，生成pinballs和ELFies速度会更快，这对于binaries频繁重编译的研究是有用的。

## 4. Case Studies

In this section, we present some case studies showing the application of ELFies to performance analysis and simulation. Although the focus mostly is architecture simulation, many other dynamic analyses can benefit from the ability to focus on regions of interest via ELFies.

### 4.1 Validating Simulation Region Selection with ELFies

### 4.2 Deterministic vs. Execution-Driven Multi-Threaded Simulation with Sniper

### 4.3 Application-Level vs. Full System Simulation with CoreSim

### 4.4 Binary-Driven Simulation with gem5

## 5. Related Work

Ringenberg and Mudge [23] present a methodology for converting program execution regions into Intrinsically Checkpointed Assembly Code (ITCY), which can be simulated as a binary application. Based on a functional simulator, static assembly instructions from representative regions are extracted and extra sections added to handle memory initialization, system call emulation, and exit. Application code gets relocated to a new address causing several complications. The resulting binary provides repeatable execution, much like the PinPlay replayer does with one important difference: the simulator sees the extra book-keeping code, possibly perturbing results. Their technique works for single-threaded Alpha workloads. ELFies move away from determinism provided by pinballs and ITCY, supports x86 binaries and multi-threaded workloads.

[23]给出了一种方法，将程序执行的区域，转换成ITCY，可以作为一个binary应用进行仿真。基于功能仿真器，从代表性区域中提取出静态汇编指令，加入额外的节，来处理内存初始化，系统调用仿真，并退出。应用代码进行重新定位到新的地址，导致几个问题。得到的binary可以进行重复的执行，与PinPlay replayer很像，但是有一个重要的区别：仿真器看到额外的book-keeping代码，可能会扰动结果。其技术对单线程的Alpha workloads可以工作。ELFie与pinballs和ITCY的确定性不同，支持x86 binaries和多线程workloads。

Checkpoint/restore in user space (CRIU) [14] is a very robust and popular checkpointing technique on Linux and was described in Section I. DMTCP [24] is a user-level checkpointing technique for distributed, multi-threaded checkpointing. A dynamic library is injected in each user process started under their checkpoint command with a checkpointing manager thread spawned. User-space state is saved, data in the network is drained to process memory, and kernel state (including open file descriptors) is probed and stored in the checkpoint. The restart under DMTCP has significant complexity around restoring the kernel state. DMTCP does not support statically-linked program binaries. DMTCP checkpoints are not stand-alone executables like ELFies and are, in general, larger.

CRIU是Linux上一个非常文件和流行的checkpointing技术。DMTCP是一个用户级的checkpointing技术，用于分布式多线程的checkpointing。

## 6. Summary

Analyzing entire runs of large programs can be time consuming. Analyzing only interesting portions from long-running executions poses the challenge of precisely reaching the regions for multiple analyses. We address this challenge by presenting a set of tools that capture regions of interest from program executions into stand-alone executables called ELFies. ELFies always start with the exact same program state captured at the beginning of the regions of interest, avoiding the time and the uncertainty in reaching those regions. While ELFies are generated using a Pin-based tool-chain, they can be run natively or with any analysis tool, Pin-based or not, that executes program binaries. Also, they can be easily shared among researchers for reproducing analysis results and comparing analyses with the exact same input binary.

分析大型程序的完整运行会非常耗时。从长期运行的执行中，只分析感兴趣的部分，在多次分析中，精确的达到这个区域是一个挑战。我们解决这个挑战，给出一个工具集，从程序执行中，将感兴趣区域捕获成一个独立的可执行文件，称为ELFies。ELFies永远会从捕获的感兴趣区域的开始的程序状态开始，避免到达这些区域的时间和不确定性问题。ELFies的生成是用基于Pin的工具链，它们的运行可以是本地的，也可以是用一些分析工具，执行程序的binaries。同时，可以在研究者之间很容易的共享，以复现分析结果，比较用相同输入binary的分析。

As part of our work, we created thousands of ELFies for regions of interest from popular single and multi-threaded benchmarks. We showcase the use of ELFies for simulation, native performance analysis and for validating simulation region selection. We believe that ELFies can be useful in many scenarios and have made our tools publicly available [16].

我们还对流行的单线程和多线程基准测试的感兴趣区域，创建了数千个ELFies。我们展示了ELFies进行仿真的用处，本地性能分析，和验证仿真区域选择中的应用。我们相信ELFies在很多场景中都是有用的，并将该工具开源。