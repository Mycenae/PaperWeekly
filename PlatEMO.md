# PlatEMO: A MATLAB Platform for Evolutionary Multi-Objective Optimization

Ye Tian et. al. @ AnHui University

## 0. Abstract

Over the last three decades, a large number of evolutionary algorithms have been developed for solving multi-objective optimization problems. However, there lacks an up-to-date and comprehensive software platform for researchers to properly benchmark existing algorithms and for practitioners to apply selected algorithms to solve their real-world problems. The demand of such a common tool becomes even more urgent, when the source code of many proposed algorithms has not been made publicly available. To address these issues, we have developed a MATLAB platform for evolutionary multi-objective optimization in this paper, called PlatEMO, which includes more than 50 multi-objective evolutionary algorithms and more than 100 multi-objective test problems, along with several widely used performance indicators. With a user-friendly graphical user interface, PlatEMO enables users to easily compare several evolutionary algorithms at one time and collect statistical results in Excel or LaTeX files. More importantly, PlatEMO is completely open source, such that users are able to develop new algorithms on the basis of it. This paper introduces the main features of PlatEMO and illustrates how to use it for performing comparative experiments, embedding new algorithms, creating new test problems, and developing performance indicators. Source code of PlatEMO is now available at: http://bimk.ahu.edu.cn/index.php?s=/Index/Software/index.html.

在过去三十年，为求解多目标优化问题，提出了大量演化算法。但是，研究者和实践者缺少一个最新的综合软件平台，对现有的算法进行合适的基准测试，应用选择的算法求解其真实世界的问题。很多提出的算法的源代码并不是公开可用的，所以对这样一种通用工具的需求就更加迫切了。为处理这个问题，我们在本文中开发了一个多目标优化的演化算法MATLAB平台，称为PlatEMO，包含了超过50种多目标演化算法，和超过100个多目标测试问题，和几种广泛使用的性能指示器。PlatEMO有用户友好的用户界面，用户可以很容易的同时比较几种演化算法，将统计结果收集成Excel或LaTeX文件。更重要的是，PlatEMO是完全开源的，这样用户可以基于其开发新的算法。本文介绍了PlatEMO的主要特征，描述了怎么使用进行比较性试验，嵌入新的算法，创建新的测试问题，并开发性能指示器。代码已开源。

## 1. Introduction

Multi-objective optimization problems (MOPs) widely exist in computer science such as data mining [1], pattern recognition [2], image processing [3] and neural network [4], as well as many other application fields [5]–[8]. An MOP consists of two or more conflicting objectives to be optimized, and there often exist a set of optimal solutions trading off between different objectives. Since the vector evaluated genetic algorithm (VEGA) was proposed by Schaffer in 1985 [9], a number of multi-objective evolutionary algorithms (MOEAs) have been proposed and shown their superiority in tackling MOPs during the last three decades. For example, several MOEAs based on Pareto ranking selection and fitness sharing mechanism including multi-objective genetic algorithm (MOGA) [10], non-dominated sorting genetic algorithm (NSGA) [11], and niched Pareto genetic algorithm (NPGA) [12] were proposed in the 1990s. From 1999 to 2002, some MOEAs characterized by the elitism strategy were developed, such as non-dominated sorting genetic algorithm II (NSGA-II) [13], strength Pareto evolutionary algorithm 2 (SPEA2) [14], Pareto envelope-based selection algorithm II (PESA-II) [15] and cellular multiobjective genetic algorithm (cellular MOGA) [16]. Afterwards, the evolutionary algorithm based on decomposition (MOEA/D) was proposed in 2007 [17], and some other MOEAs following the basic idea of MOEA/D had also been developed since then [18]–[21].

多目标优化问题(MOPs)在计算机科学中广泛存在，如数据挖掘，模式识别，图像处理和神经网络，以及很多其他应用领域。一个MOP由两个或多个待优化的互相冲突的目标构成，通常存在不同的目标之间折中最优解集合。自从Schaffer在1985年提出了向量评估的遗传算法(VEGA)，在过去三十年中，出现了很多多目标演化算法(MOEA)，在处理MOPs中展现了它们的优越性。比如，在1990s年代，提出了几种基于Pareto排序选择和适应度共享机制的MOEAs，包括多目标遗传算法(MOGA)，非占优排序遗传算法(NSGA)，niched Pareto遗传算法(NPGA)等。从1999到2002年，提出了几种基础精英主义策略的MOEAs，比如，非占优排序遗传算法II(NSGA-II)，强度Pareto演化算法2(SPEA2)，Pareto基于包络线的选择算法II(PESA-II)，和蜂窝多目标遗传算法(cellular MOGA)。后来，2007年提出了基于分解的演化算法(MOEA/D)，自从那时还提出了按照MOEA/D基本思想的几个其他MOEAs。

In spite of a large number of MOEAs in the literature [22], there often exist some difficulties in applying and using these algorithms since the source code of most algorithms had not been provided by the authors. Besides, it is also difficult to make benchmark comparisons between MOEAs due to the lack of a general experimental environment. To address such issues, several MOEA libraries have been proposed to provide uniform experimental environments for users [23]–[30], which have greatly advanced the multi-objective optimization research and the implementation of new ideas. For example, the C-based multi-objective optimization library PISA [27] separates the implementation into two components, i.e., the problem-specific part containing MOPs and operators, and the problem-independent part containing MOEAs. These two components are connected by a text file-based interface in PISA. jMetal [23] is an object-oriented Java-based multi-objective optimization library consisting of various MOEAs and MOPs. MOEA Framework is another free and open source Java framework for multi-objective optimization, which provides a comprehensive collection of MOEAs and tools necessary to rapidly design, develop, execute and test MOEAs. OTL [25], a C++ template library for multi-objective optimization, is characterized by object-oriented architecture, template technique, ready-to-use modules, automatically performed batch experiments and parallel computing. Besides, a Python-based experimental platform has also been proposed as the supplement of OTL, for improving the development efficiency and performing batch experiments more conveniently. ParadisEO-MOEO [26] is also a notable MOEA library designed on the basis of reconfigurable components. It provides a wide range of archive-related features and fitness assignment strategies used in the most common Pareto-based evolutionary algorithms, such that users can use the library to generate a large number of new MOEAs by recombining these components. AutoMOEA [30] is another recently proposed MOEA template extended from ParadisEO-MOEO, which has a higher generality and more comprehensive coverage of algorithms and operators. In addition, a similar framework was also adopted in ParadisEO-MO for the design of single solution-based metaheuristics [31].

尽管文献中有大量MOEAs，使用和应用这些算法存在一些困难，因为多数算法的源代码都没有公开。因此，MOEAs之间进行基准测试比较就很困难，因为缺少通用的试验环境。为解决这个问题，给出了几个MOEA库，以为用户提供统一试验环境，极大了推进了多目标优化研究，和新想法的实现。比如，基于C的多目标优化库PISA将实现分成了两个部分，即，问题特定的部分，包含MOPs和算子，和问题无关的部分，包含MOEAs。这两个部分是由PISA中一个基于文本的接口连接的。jMetal是一个面向对象的基于Java的多目标优化库，包含各种MOEAs和MOPs。MOEA框架是另一个免费开源的多目标优化Java框架，给出了很多MOEAs和工具的集合，可以快速的设计，开发，执行和测试MOEAs。OTL是一个多目标优化C++模板库，有面向对象的框架，模板技术，开箱即用的模块，自动执行的批试验和并行计算。另外，作为OTL的附属，还提出了一个基于Python的试验平台，用于改进开发效率，更方便的进行批试验。ParadisEO-MOEO也是一个著名的MOEA库，以可重配置的部分为基础进行设计。它提供了大量档案相关的特征，和适应度指定策略，在多数常见的基于Pareto演化算法中都可以使用，这样用户可以用这些库，通过重新组合这些部分来生成大量新MOEAs。AutoMOEA是另一个最近提出的MOEA模板，从ParadisEO-MOEO拓展而来，有更高的通用性和对算法和算子更广泛的覆盖。另外，在ParadisEO-MO中采用了类似的框架，用户单个基于解的元启发式的设计。

It is encouraging that there are several MOEA libraries dedicated to the development of evolutionary multi-objective optimization (EMO), but unfortunately, most of them are still far from useful and practical to most researchers. Besides, due to the lack of professional GUI for experimental settings and algorithmic configurations, these libraries are difficult to be used or extended, especially for beginners who are not familiar with EMO. In order to collect more modern MOEAs and make the implementation of experiments on MOEAs easier, in this paper, we introduce a MATLAB-based EMO platform called PlatEMO. Compared to existing EMO platforms, PlatEMO has the following main advantages:

有一些MOEA库致力于演化多目标优化(EMO)的开发，这很鼓舞人心，但不幸的是，对于研究者来说，大多数距离有用和实际可用还很远。另外，由于缺少专业的GUI进行试验设置和算法配置，这些库很难使用或拓展，尤其是对于EMO不太熟悉的初学者。为收集更多的现代MOEAs，让在MOEAs的试验实现更容易，在本文中，我们提出了一种基于Matlab的EMO平台，称为PlatEMO。与现有的EMO平台相比，PlatEMO有以下主要优势：

**Rich Library**. PlatEMO now includes 50 existing popular MOEAs published in important journals or conferences in evolutionary computation community as shown in Table 1, which cover a variety of different types, including multi-objective genetic algorithms, multi-objective differential evolution algorithms, multi-objective particle swarm optimization algorithms, multi-objective estimation of distribution algorithms, and surrogate-assisted multi-objective evolutionary algorithms. PlatEMO also contains 110 MOPs from 16 popular test suites covering various difficulties, which are listed in Table 2. In addition, there are a lot of performance indicators provided by PlatEMO for experimental studies, including Coverage [75], generational distance (GD) [89], hypervolume (HV) [90], inverted generational distance (IGD) [91], normalized hypervolume (NHV) [41], pure diversity (PD) [92], spacing [93], spread (Δ) [94], and the performance metric ensemble [95]. PlatEMO also provides a lot of widely-used operators for different encodings [96]–[102], which can be used together with all the MOEAs in PlatEMO.

丰富的库。PlatEMO现在包括50种现有的流行MOEAs，发表在了重要的演化计算期刊或会议中，如表1所示，覆盖了大量不同的类型，包括多目标遗传算法，多目标微分演化算法，多目标粒子群优化算法，多目标估计分布算法，代理辅助的多目标演化算法。PlatEMO还包含110种MOPs，来自16个流行的测试包，覆盖了各种难度，列在了表2中。另外，PlatEMO给出了几个性能指示器，用于试验研究，包括Coverage，generational distance (GD)，hypervolume(HV)，inverted generational distance(IGD)，归一化hypervolume(NHV)，pure diversity(PD)，spacing，spread，和性能度量集成。PlatEMO还给出了大量广泛使用的算子，用于不同的编码，可以在PlatEMO中在所有MOEAs可以一起使用。

**Good Usability**. PlatEMO is fully developed in MATLAB language, thus any machines installed with MATLAB can use PlatEMO regardless of the operating system. Besides, users do not need to write any additional code when performing experiments using MOEAs in PlatEMO, as PlatEMO provides a user-friendly GUI, where users can configure all the settings and perform experiments on MOEAs via the GUI, and the experimental results can further be saved as a table in the format of Excel or LaTeX. In other words, with the assistance of PlatEMO, users can directly obtain the statistical experimental results to be used in academic writings by one-click operation via the GUI.

很好的可用性。PlatEMO是完全用Matlab开发的，因此任何安装了MATLAB的机器都可以使用PlatEMO，不论操作系统是什么。此外，在使用PlatEMO中的MOEAs进行试验时，用户不需要写额外的代码，因为PlatEMO提供了用户友好的GUI，用户可以在GUI中配置所有的色值，在MOEAs上进行试验，试验结果可以进一步保存成Excel或LaTeX格式的表格。换句话说，有了PlatEMO的协助，用户通过GUI上的一次点击操作，就可以直接得到统计试验结果，用在学术写作中。

**Easy Extensibility**. PlatEMO is not only easy to be used, but also easy to be extended. To be specific, the source code of all the MOEAs, MOPs and operators in PlatEMO are completely open source, and the length of the source code is very short due to the advantages of matrix operation in MATLAB, such that users can easily implement their own MOEAs, MOPs and operators on the basis of existing resources in PlatEMO. In addition, all new MOEAs developed on the basis of interfaces provided by PlatEMO can be also included in the platform, such that the library in PlatEMO can be iteratively updated by all users to follow state-of-the-arts.

容易的拓展性。PlatEMO不仅容易使用，还容易拓展。具体来说，PlatEMO中所有MOEAs，MOPs和算子的源代码都是完全开源的，源码很短，因为MATLAB中矩阵操作的优势，这样用户可以基于PlatEMO中已有的资源的基础上，很容易的实现他们自己的MOEAs，MOPs和算子。另外，在PlatEMO给出的接口的基础上，所有新的MOEAs都可以纳入到平台中，这样PlatEMO中的库可以由所有用户迭代的进行更新，以达到目前最好的状态。

**Delicate Considerations**. There are many delicate considerations in the implementation of PlatEMO. For example, PlatEMO provides different figure demonstrations of experimental results, and it also provides well-designed sampling methods which are able to generate an arbitrary number of uniformly distributed points on the Pareto optimal fronts with an arbitrary number of objectives. Fig. 1 shows the reference points sampled by PlatEMO on the Pareto optimal fronts of some MOPs with 3 objectives, while such reference points have not been provided by any other existing EMO libraries. It is also worth noting that, since the efficiency of most MOEAs is subject to the non-dominated sorting process, PlatEMO employs the efficient non-dominated sort ENS-SS [103] for two- and three-objective optimization and the tree-based ENS termed T-ENS [60] for optimization with more than three objectives as the non-dominated sorting approaches, which have been demonstrated to be much more efficient than the widely adopted fast non-dominated sorting approach [13] as well as other popular non-dominated sorting approaches [104].

精致的考虑。在PlatEMO的实现中，有很多精致的考虑。比如，PlatEMO对试验结果给出了不同的图表示，还给出了设计良好的采样方法，可以在Pareto最优front上以任意数量的目标函数，生成任意数量的均匀分布的点。图1展示了PlatEMO在一些MOPs的Pareto最优fronts以3个目标采样得到的参考点，而任何其他现有的EMO库都不能给出这样的参考点。还值得指出的是，由于多数MOEAs的效率是与非占优排序过程相关的，PlatEMO对两个或三个目标优化采用了高效的非占优排序ENS-SS，对多于三个目标优化的情况提供了基于树的ENS，称为T-ENS，因为非占优的排序方法已经证明了比广泛采用的快速非占优排序方法，和其他流行的非占优排序方法，要高效。

Table 3 lists the main characteristics of PlatEMO in comparison with other existing MOEA libraries. As shown in the table, PlatEMO provides a variety of MOEAs and MOPs with different types, where the types of MOEAs cover genetic algorithm, differential algorithm, particle swarm optimization, memetic algorithm, estimation of distribution algorithm, surrogate-assisted evolutionary algorithm and the types of MOPs have multi-objective, many-objective, combinatorial, large-scale and expensive optimization problem. The PlatEMO shows significant superiority in usability of MOEAs and extendibility of adding new MOEAs, while ParadisEO-MOEO has the best configurability in terms of generating new MOEAs by combining different components.

表3列出了PlatEMO与其他已有的MOEAs库相比的主要特征。如表所示，PlatEMO提供了各种不同类型的大量MOEAs和MOPs，其中MOEAs的类型覆盖了遗传算法，差分算法，粒子群优化，文化基因算法，分布估计算法，代理辅助演化算法，MOPs的类型有，多目标，众目标，组合，大规模和昂贵的优化问题。PlatEMO在MOEAs的使用性和拓展性，如加入新的MOEAs上展现出了明显的优势，而ParadisEO-MOEO有最好的可配置性，通过组合不同的部分就可以生成新的MOEAs。

The rest of this paper is organized as follows. In the next section, the architecture of PlatEMO is presented on several aspects, i.e., the file structure of PlatEMO, the class diagram of PlatEMO, and the sequence diagram of executing algorithms by PlatEMO. Section III introduces how to use PlatEMO for analyzing the performance of algorithms and performing comparative experiments. The methods of extending PlatEMO with new MOEAs, MOPs, operators and performance indicators are described in Section IV. Finally, conclusion and future work are given in Section V.

本文如下部分组织如下。下一节给出PlatEMO的架构的几个方面，即PlatEMO的文件结构，PlatEMO的类图，PlatEMO执行算法的顺序图。第三部分介绍了怎样使用PlatEMO，分析了算法的性能，进行了比较性的试验。在第四部分，介绍了拓展PlatEMO的方法，加入新的MOEAs，MOPs，算子和性能指示器。最后，在第五部分给出了结论和未来工作。

## 2. Architecture of PlatEMO

After opening the root directory of PlatEMO, users can see a lot of .m files organized in the structure shown in Fig. 2, where it is very easy to find the source code of specified MOEAs, MOPs, operators or performance indicators. As shown in Fig. 2, there are six folders and one interface function main.m in the root directory of PlatEMO. The first folder \Algorithms is used to store all the MOEAs in PlatEMO, where each MOEA has an independent subfolder and all the relevant functions are in it. For instance, as shown in Fig. 2, the subfolder \Algorithms\NSGA-II contains three functions NSGAII.m, CrowdingDistance.m and EnvironmentalSelection.m, which are used to perform the main loop, calculate the crowding distances, and perform the environmental selection of NSGA-II, respectively. The second folder \Problems contains a lot of subfolders for storing benchmark MOPs. For example, the subfolder \Problems\DTLZ contains 15 DTLZ test problems (i.e., DTLZ1–DTLZ9, C1_DTLZ1, C2_DTLZ2, C3_DTLZ4, IDTLZ1, IDTLZ2 and CDTLZ2), and the subfolder \Problems\WFG contains 9 WFG test problems (i.e., WFG1–WFG9). The folders \Operators and \Metrics store all the operators and performance indicators, respectively. The next folder \Public is used to store some public classes and functions, such as GLOBAL.m and INDIVIDUAL.m, which are two classes in PlatEMO representing settings of parameters and definitions of individuals, respectively. The last folder \GUI stores all the functions for establishing the GUI of PlatEMO, where users need not read or modify them.

在打开PlatEMO的根目录后，用户可以看到很多.m文件，组织结构如图2所示，可以很容易的找到指定的MOEAs，MOPs，算子或性能指示器的源代码。如图2所示，在PlatEMO的根目录下，有6个文件夹，和一个接口函数main.m。第一个文件夹\Algorithms用于存储PlatEMO中的所有MOEAs，其中每个MOEA有一个独立的子文件夹，所有相关的文件都在其中。比如，如图2所示，子文件夹\Algorithms\NSGA-II包含3个函数NSGAII.m, CrowdingDistance.m和EnvironmentalSelection.m，分别用于进行主循环，计算crowding距离，进行NSGA的环境选择。第二个文件夹\Problems包含很多子文件夹，用于存储基准测试MOPs。比如，子文件夹\Problems\DTLZ包含15个DTLZ测试问题（即，DTLZ1–DTLZ9, C1_DTLZ1, C2_DTLZ2, C3_DTLZ4, IDTLZ1, IDTLZ2和CDTLZ2），子文件夹\Problems\WFG包含9个WFG测试问题（即，WFG1-WFG9）。文件夹\Opterators和\Metrics分别存储了所有的算子和性能指示器。下一个文件夹\Public用于存储一些公开的类和函数，比如GLOBAL.m和INDIVIDUAL.m，这是PlatEMO中的两个类，分别表示参数的设置，和个体的定义。最后一个文件夹\GUI存储了PlatEMO的GUI的函数，用户不需要对其进行读写。

PlatEMO also has a simple architecture, where it only involves two classes, namely GLOBAL and INDIVIDUAL, to store all the parameters and joint all the components (e.g., MOEAs, MOPs and operators). The class diagram of these two classes is presented in Fig. 3. The first class GLOBAL represents all the parameter setting, including the handle of MOEA function algorithm, the handle of MOP function problem, the handle of operator function operator and other parameters about the environment (the population size, the number of objectives, the length of decision variables, the maximum number of fitness evaluations, etc.). Note that all the properties in GLOBAL are read-only, which can only be assigned by users when the object is being instantiated. GLOBAL also provides several methods to be invoked by MOEAs, where MOEAs can achieve some complex operations via these methods. For instance, the method Initialization() can generate a randomly initial population with specified size, and the method Variation() can generate a set of offsprings with specified parents.

PlatEMO的架构很简单，只涉及到两类，即GLOBAL和INDIVIDUAL，来存储所有的参数，连接所有的部分（如，MOEAs，MOPs和算子）。这两个类的类图如图3所示。第一个类GLOBAL表示所有的参数设置，包括MOEA函数算法的句柄，MOP函数问题的句柄，算子函数和其他关于环境的参数的句柄（种群大小，目标数量，决策变量的长度，适应度评估的最大数量，等）。注意，GLOBAL的所有属性都是只读的，只有在对象实例化的时候，才会由用户指定。GLOBAL还提供了一些方法来供MOEAs调用，MOEAs通过这些方法可以实现更复杂的运算。比如，方法Initialization()可以以指定的大小生成随机初始种群，方法Variation()可以用指定的父代生成子代集合。

The other class in PlatEMO is INDIVIDUAL, where its objects are exactly individuals in MOEAs. An INDIVIDUAL object contains four properties, i.e., dec, obj, con and add, all of which are also read-only. dec is the array of decision variables of the individual, which is assigned when the object is being instantiated. obj and con store the objective values and the constraint values of the individual, respectively, which are calculated after dec has been assigned. The property add is used to store additional properties of the individual for some special operators, such as the ‘speed’ property in PSO operator [101].

PlatEMO中的另一个类是INDIVIDUAL，其中的对象是MOEAs中的个体。一个INDIVIDUAL对象包含4个属性，即，dec，obj，con和add，这也都是只读的。dec是个体的决策变量的阵列，当对象实例化的时候指定的。obj和con存储的分别是个体的目标函数值和约束函数值，是在dec指定后计算得到的。add属性用于对一些特殊的算子，存储个体的额外属性，比如PSO算子中的speed属性。

In order to better understand the mechanism of PlatEMO, Fig. 4 illustrates the sequence diagram of running an MOEA by PlatEMO without GUI. To begin with, the interface main.m first invokes the algorithm function (e.g., NSGAII.m), then the algorithm obtains an initial population (i.e., an array of INDIVIDUAL objects) from the GLOBAL object by invoking its method Initialization(). After that, the algorithm starts the evolution until the termination criterion is fulfilled, where the maximum number of fitness evaluations is used as the termination criterion for all the MOEAs in PlatEMO. In each generation of a general MOEA, it first performs mating pool selection for selecting a number of parents from the current population, and the parents are used to generate offsprings by invoking the method Variation() of GLOBAL object. Variation() then passes the parents to the operator function (e.g., DE.m), which is used to calculate the decision variables of the offsprings according to the parents. Next, the operator function invokes the INDIVIDUAL class to instantiate the offspring objects, where the objective values of offsprings are calculated by invoking the problem function (e.g., DTLZ1.m). After obtaining the offsprings, the algorithm performs environmental selection on the current population and the offsprings to select the population for next generation. When the number of instantiated INDIVIDUAL objects exceeds the maximum number of fitness evaluations, the algorithm will be terminated and the final population will be output.

为更好的理解PlatEMO的机制，图4给出了PlatEMO在没有GUI的情况下，运行一个MOEA的顺序图。开始时，接口main.m首先调用算法函数（如，NSGAII.m），然后算法从GLOBAL对象中，通过调用其方法Initialization()，得到初始种群（即，INDIVIDUAL对象的一个阵列）。伺候，算法开始演化，直到满足停止条件，PlatEMO中，所有的MOEAs都使用适应度评估的最大次数作为停止条件。在一般性MOEA的每一代中，首先进行mating pool选择，以从当前的种群中选择一定数量的父代，通过调用GLOBAL对象的方法Variation()，父代用于生成子代。Variation()将父代送入算子函数（如，DE.m），用于根据父代计算子代的决策变量。然后，算子函数调用INDIVIDUAL类，来实例化子代对象，子代的目标值是通过调用问题函数（如，DTLZ1.m）来计算得到的。在得到子代后，算法在当前种群和子代的基础上进行环境选择，以选择下一代的种群。当实例化的INDIVIDUAL对象的数量超过了适应度评估的最大次数，算法会停止，输出最终的种群。

As presented by the above procedure, the algorithm function, the problem function and the operator function do not invoke each other directly; instead, they are connected to each other by the GLOBAL class and the INDIVIDUAL class. This mechanism has two advantages. First, MOEAs, MOPs and operators in PlatEMO are independent mutually, and they can be arbitrarily combined with each other, thus improved the flexibility of PlatEMO. Second, users need not consider the details of the MOP or the operator to be involved when developing a new MOEA, thus significantly improving the development efficiency.

如上述过程给出的，算法函数，问题函数和算子函数不会直接互相调用；它们通过GLOBAL类和INDIVIDUAL类相互连接。这个机制有两个优势。第一，PlatEMO中的MOEAs，MOPs和算子是相互独立的，可以随机的相互组合，因此改进了PlatEMO的灵活性。第二，当开发新的MOEA时，用户不需要考虑涉及到的MOP或算子的细节，因此显著改进了开发效率。

## 3. Running PlatEMO

As mentioned in Section I, PlatEMO provides two ways to run it: first, it can be run with a GUI by invoking the interface main() without input parameter, then users can perform MOEAs on MOPs by simple one-click operations; second, it can be run without GUI, and users can perform one MOEA on an MOP by invoking main() with input parameters. In this section, we elaborate these two ways of running PlatEMO.

在第1部分中提过，PlatEMO有两种方法运行：可以通过调用接口main()不需要输入参数带GUI运行，用户可以通过简单的点击操作在MOPs上运行MOEAs；第二，可以通过无GUI运行，用户可以调用main()带有输入参数，在一个MOP上运行一个MOEA。本节中，我们详细介绍两种运行PlatEMO的方式。

### 3.1. Running PlatEMO without GUI

The interface main() can be invoked with a set of input parameters by the following form: main(’name1’, value1, ’name2’, value2,…), where name1, name2,… denote the names of the parameters and value1, value2,… denote the values of the parameters. All the acceptable parameters together with their data types and default values are listed in Table 4. It is noteworthy that every parameter has a default value so that users need not assign all the parameters. As an example, the command main(’-algorithm’,@NSGAII,’-problem’,@DTLZ2,’-N’,100,’-M’,3,’-D’,10,’-evaluation’,10000) is used to perform NSGAII on DTLZ2 with a population size of 100, an objective number of 3, a decision variable length of 10, and a maximum fitness evaluation number of 10000.

接口main()可以用输入参数集进行调用，形式如下：main(’name1’, value1, ’name2’, value2,…)，其中name1, name2, ...表示参数名称，value1，value2，...表示参数的值。表4给出了所有可接受的参数，以及其数据类型，和默认值。值得指出的是，每个参数都有默认值，所以用户不需要指定所有参数。比如，命令main(’-algorithm’,@NSGAII,’-problem’,@DTLZ2,’-N’,100,’-M’,3,’-D’,10,’-evaluation’,10000)用于在DTLZ2运行NSGAII算法，族群大小100，目标函数数量3，决策变量长度10，最大适应度评估次数10000。

By invoking main() with parameters, one MOEA can be performed on an MOP with the specified setting, while the GUI will not be displayed. After the MOEA has been terminated, the final population will be displayed or saved, which is determined by the parameter -mode shown in Table 4. To be specific, if -mode is set to 1, the objective values or decision variable values of the final population will be displayed in a new figure, and users can also observe the true Pareto front and the evolutionary trajectories of performance indicator values. For example, Fig. 5 shows the objective values of the population obtained by NSGA-II on DTLZ2 with 3 objectives, where users can select the figure to be displayed on the rightmost menu. If -mode is set to 2, the final population will be saved in a .mat file, while no figure will be displayed. If -mode is set to 3, users can specify any operation to be performed on the final population, e.g., displaying and saving the population concurrently.

通过带有参数调用main()函数，可以在一个MOP上以指定的设置进行一个MOEA，而GUI则不会显示。在MOEA停止以后，最终的种群会显示或保存，这由表4中的-mode参数决定。具体来说，如果-mode设为1，最终种群的目标值或决策变量值会在新的figure中展示出来，用户还可以观察到真实的Pareto front和性能指示器值的演化轨迹。比如，图5展示了NSGA-II在DTLZ2上以3个目标得到的种群的目标值，其中用户可以在菜单的最右边选择要展示的图。如果-mode设为2，最终的种群会被保存到一个.mat文件中，不会展示figure。如果-mode设为3，用户可以指定在最终种群上要进行的任意操作，如，同时展示和保存种群。

Generally, as listed in Table 4, four parameters related to the optimization can be assigned by users (i.e., the population size -N, the number of objectives -M, the number of decision variables -D, and the maximum number of fitness evaluations -evaluation); however, different MOEAs, MOPs or operators may involve additional parameter settings. For instance, there is a parameter rate denoting the ratio of selected knee points in KnEA [49], and there are four parameters proC, disC, proM and disM in EAreal[96], [97], which denote the crossover probability, the distribution index of simulated binary crossover, the number of bits undergone mutation, and the distribution index of polynomial mutation, respectively. In PlatEMO, such function related parameters can also be assigned by users via assigning the parameter -X_parameter, where X indicates the name of the function. For example, users can use the command main(…,’-KnEA_parameter’,{0.5},…) to set the value of rate to 0.5 for KnEA, and use the command main(…,’-EAreal_parameter’, {1,20,1,20},…) to set the values of proC, disC, proM and disM to 1, 20, 1 and 20 for EAreal, respectively. Besides, users can find the acceptable parameters of each MOEA, MOP and operator in the comments at the beginning of the corresponding function.

一般来说，如表4中所列，用户可以指定与优化相关的4个参数（即，种群大小-N，目标数量-M，决策变量数量-D，最大适应度评估次数-evaluation）；但是，不同的MOEAs，MOPs或算子可能会涉及到额外的参数设置。如，在KnEA[49]中有一个参数rate表示选择的knee点的比例，在EAreal中，有4个参数proC，disC，proM和disM，分别表示crossover概率，仿真的二值crossover的分布索引，正在变异的bits数量，多项式变异的分布索引。在PlatEMO中，这样的与函数有关的参数也可以由用户通过指定参数-X_parameter来指定，其中X表示函数的名称。如，用户可以用命令main(…,’-KnEA_parameter’,{0.5},…)来位KnEA设置rate参数为0.5，使用命令main(…,’-EAreal_parameter’, {1,20,1,20},…)将proC, disC, proM和disM的值设为1，20，1和20。另外，用户可以为每个MOEA，MOP和算子，在对应的函数的开始，在注释中找到可接受的参数。

### 3.2. Running PlatEMO with GUI

The GUI of PlatEMO currently contains two modules. The first module is used to analyze the performance of each MOEA, where one MOEA on an MOP can be performed in this module each time, and users can observe the result via different figure demonstrations. The second module is designed for statistical experiments, where multiple MOEAs on a batch of MOPs can be performed at the same time, and the statistical experimental results can be saved as Excel table or LaTeX table.

PlatEMO的GUI目前包含两个模块。第一个模块用于分析每个MOEA的性能，其中一个MOP上的一个MOEA每次都可以在这个模块中运行，用户可以通过不同的figure展示来观察结果。第二个模块设计用于统计试验，在一批MOPs上的多个MOEAs可以同时进行，统计试验结果可以保存成Excel或LaTeX表格。

The interface of the first module, i.e., test module, is shown in Fig. 6. As can be seen from the figure, the main panel is divided into four parts. The first subpanel from left provides three pop up menus, where users can select the MOEA, MOP and operator to be performed. The second subpanel lists all the parameters to be assigned, which depends on the selected MOEA, MOP and operator. The third subpanel displays the current population during the optimization, other figures such as the true Pareto front and the evolutionary trajectories of performance indicator values can also be displayed. In addition, users can observe the populations in previous generations by dragging the slider at the bottom. The fourth subpanel stores the detailed information of historical results. As a result, the test module provides similar functions to the PlatEMO without GUI, but users do not need to write any additional command or code when using it.

第一个模块的界面，即测试模块，如图6所示。从图中可以看到，主面板分成4部分。左边的第一个子面板有3个弹出式菜单，用户可以选择要进行的MOEA，MOP和算子。第二个子面板列出了要指定的所有参数，这依赖于选择的MOEA，MOP和算子。第三个子面板展示了在优化过程中当前的种群，也可以展示其他的图，如真实的Pareto front，和性能指示器值的演化轨迹。另外，用户可以通过拖动底部的滑块，来观察之前代的种群。第四个子面板存储的是历史结果的详细信息。结果是，测试模块给出了与无GUI的PlatEMO类似的函数，但用户在使用时不需要写任何额外的命令或代码。

The other module on the GUI is the experimental module, which is shown in Fig. 7. Similar to the test module, users should first select the MOEAs, MOPs and operators to be performed in the leftmost subpanel. Note that multiple MOEAs and MOPs can be selected in the experimental module. After setting the number of total runs, folder for saving results, and all the relevant parameters, the experiment can be started and the statistical results will be shown in the rightmost subpanel. Users can select any performance indicator to calculate the results to be listed in the table, where the mean and the standard deviation of the performance indicator value are shown in each grid. Furthermore, the best result in each row is shown in blue, and the Wilcoxon rank sum test result is labeled by the signs ‘+’, ‘–’ and ‘≈’, which indicate that the result is significantly better, significantly worst and statistically similar to the result in the control column, respectively. After the experiment is finished, the data shown in the table can be saved as Excel table (.xlsx file) or LaTeX table (.tex file). For example, after obtaining the experimental results shown in the table in Fig. 7, users can press the ‘saving’ button on the GUI to save the table in the format of LaTeX, where the corresponding LaTeX table is shown in Table 5.

GUI的另一个模块是试验模块，如图7所示。与测试模块类似，用户应当首先在最左边的子面板上选择要进行的MOEAs，MOPs和算子。注意在试验模块，可以选择多个MOEAs和MOPs。在设置总计运行次数，保存结果的文件夹和所有相关的参数后，试验可以开始，统计结果会展示在最右边的子面板中。用户可以选择任何性能指示器来计算列在表中的结果，性能指示器值的均值和标准差会展示在每个格子中。而且，在每行中的最佳结果用蓝色显示，Wilcoxon rank sum test结果用标签+，-和≈标记出来，分别表示结果明显更好，明显更坏和统计上与控制列中的结果类似。在试验结束后，表中展示的数据可以存储为Excel或Latex表格。比如，在得到图7中所示的表格的结果后，用户可以在GUI中点击saving按钮，用LaTeX格式保存表格，其中对应的LaTeX表格如表5所示。

It can be concluded from the above introduction that the functions provided by PlatEMO are modularized, where two modules (i.e., the test module and the experimental module) are included in the current version of PlatEMO. In the future, we also plan to develop more modules to provide more functions for users.

从上面的介绍中可以得出结论，PlatEMO提供的功能是模块化的，目前版本的PlatEMO包含了两个模块（即，测试模块和试验模块）。在未来，我们还计划开发更多的模块，为用户提供更多的功能。

## 4. Extending PlatEMO

PlatEMO is an open platform for scientific research and applications of EMO, hence it allows users to add their own MOEAs, MOPs, operators and performance indicators to it, where users should save the new MOEA, MOP, operator or performance indicator to be added as a MATLAB function (i.e., a .m file) with the specified interface and form, and put it in the corresponding folder. In the following, the methods of extending PlatEMO with a new MOEA, MOP, operator and performance indicator are illustrated by several cases, respectively.

PlatEMO是EMO科学研究和应用的一个开放平台，因此允许用户增加他们自己的MOEAs，MOPs，算子和性能指示器。，用于应当将新的MOEA，MOP，算子或性能指示器保存成一个MATLAB函数（即，一个.m文件），要有指定的接口和形式，放入对应的文件夹中。下面，用几个例子分别描述将新的MOEA，MOP，算子和性能指示器加入到PlatEMO中的方法。

### 4.1. Adding New Algorithms to PlatEMO

In order to add a new MOEA to PlatEMO, users only need to slightly modify the input and output of their MATLAB function of the algorithm as required by PlatEMO, and put the function (.m file) in the folder \Algorithms of the root directory. For example, as shown in the file structure in Fig. 2, the three .m files for NSGA-II (i.e., NSGAII.m, CrowdingDistance.m and EnvironmentalSelection.m) are all in the subfolder \Algorithms\NSGA-II. A case study including the source code of the main function of NSGA-II (i.e. NSGAII.m) is given in Fig. 8, where the logic of the function is completely the same to the one shown in Fig. 4.

要向PlatEMO加入一个新的MOEA，用户只需要略微修改其算法的MATLAB函数的输入和输出，以满足PlatEMO的要求，将函数的.m文件放入根目录的\Algorithms目录。比如，如图2的文件结构所示，NSGA-II的3个.m文件（即，NSGAII.m, CrowdingDistance.m 和 EnvironmentalSelection.m）都在子文件夹\Algorithms\NSGA-II中。图8给出了NSGA-II的主函数的源代码（即，NSGAII.m）的例子，其中函数的逻辑与图4中所示的完全一样。

To begin with, the main function of an MOEA has one input parameter and zero output parameter, where the only input parameter denotes the GLOBAL object for the current run. Then an initial population Population is generated by invoking Global.Initialization(), and the non-dominated front number and the crowding distance of each individual are calculated (line 2–4). In each generation, the function Global.NotTermination() is invoked to check whether the termination criterion is fulfilled, and the variable Population is passed to this function to be the final output (line 5). Afterwards, the mating pool selection, generating offsprings, and environmental selection are performed in sequence (line 6–9).

为开始，一个MOEA的主函数有一个输入参数，和零个输出参数，其中仅有的输入参数表示当前运行的GLOBAL对象。然后通过调用Global.Initialization()生成一个初始种群Population，然后计算每个个体的非占优的front数量和crowding距离（第2-4行）。在每代中，都调用函数Global.NotTermination()来检查是否满足停止条件，变量Population送入这个函数，成为最终的输出（第5行）。后来，顺序执行mating pool选择，生成子代，和环境选择的操作。

The common code required by any MOEA is underlined in Fig. 8. In addition to the interface of the function, one MOEA needs to perform at least the following three operations: obtaining an initial population via Global.Initialization(), checking the optimization state and outputting the final population via Global.NotTermination(), and generating offsprings via Global.Variation(), where all these three functions are provided by the GLOBAL object. Apart from the above three common operations, different MOEAs may have different logics and different functions to be invoked.

图8中用下划线标出了一个MOEA需要的通用代码。除了函数的接口，一个MOEA需要至少进行下面三个运算：通过Global.Initialization()得到一个初始种群，通过Global.NotTermination()来检查优化状态，输出最终种群，通过Global.Variation()来生成子代，其中所有这三个函数都是由GLOBAL对象给出的。除了上面三个通用操作，不同的MOEAs可能要调用不同的逻辑和不同的函数。

### 4.2. Adding New Problems to PlatEMO

All the .m files of MOP functions are stored in the folder \Problems, and one .m file usually indicates one MOP. Fig. 9 gives the source code of DTLZ2, where the common code required by any MOP is underlined. It can be seen from the source code that, the interface of DTLZ2 is more complex than the one of NSGAII, where the function DTLZ2() includes three input parameters and one output parameter. The input parameter Operation determines the operation to be performed; the parameter Global denotes the GLOBAL object; and the parameter input has different meanings when Operation is set to different values, so does the output parameter varargout.

MOP函数的所有.m文件都是存储在\Problems文件夹下的，一个.m文件通常代表一个MOP。图9给出了DTLZ2的源代码，任何MOP都要有的通用代码已经加了下划线。从源代码中可以看到，DTLZ2的接口比NSGAII的要更复杂，其中函数DTLZ2()包括3个输入参数，一个输出参数。输入参数Operation确定了要进行的操作，参数Global表示GLOBAL目标；参数input在Operation设为不同的值时，有不同的意义，输出参数varargout也是。

Different from the MOEA functions which are invoked only once in each run, an MOP function may be invoked many times for different operations. As shown in Fig. 9, an MOP function contains three independent operations: generating random decision variables (line 3–10), calculating objective values and constraint values (line 11–23), and sampling reference points on the true Pareto front (line 24–27). To be specific, if Operation is set to ‘init’, the MOP function will return the decision variables of a random population with size input (line 9–10). Meanwhile, it sets Global.M, Global.D, Global.lower, Global.upper and Global.operator to their default values, which denote the number of objectives, number of decision variables, lower boundary of each decision variable, upper boundary of each decision variable, and the operator function, respectively (line 4–8). When Operation is set to ‘value’, the parameter input will denote the decision variables of a population, and the objective values and constraint values of the population will be calculated and returned according to the decision variables (line 14–23). And if Operation is set to ‘PF’, a number of input uniformly distributed reference points will be sampled on the true Pareto front and returned (line 25–27).

MOEA函数在每次运行时只调用一次，与之不同的是，MOP函数会对不同的运算调用很多次。如图9所示，MOP函数包含3个独立的操作：生成随机的决策变量（3-10行），计算目标值和约束值（11-23行），在真实的Pareto front上采样参考点（24-27行）。具体来说，如果Operation设为init，MOP函数会返回输入大小的随机种群的决策变量（9-10行）。同时，会设置Global.M, Global.D, Global.lower, Global.upper和Global.operator为其默认值，分别表示目标的数量，决策变量的数量，每个决策变量的低边界，每个决策变量的高边界，算子函数（4-8行）。当Operation设为value时，参数input会表示一个种群的决策变量，会根据决策变量来计算并返回目标值和约束值（14-23行）。如果Operation设置为PF，会在真正的Pareto front上采样输入的input数量的均匀分布的参考点并返回（25-27行）。

### 4.3. Adding New Operators or Performance Indicators to PlatEMO

Fig. 10 shows the source code of evolutionary operator based on binary coding (i.e. EAbinary.m), where the .m files of the operator functions are all stored in the folder \Operators. An operator function has two input parameters, one denoting the GLOBAL object (i.e. Global) and the other denoting the parent population (i.e. Parent), and it also has one output parameter denoting the generated offsprings (i.e. Offspring). As can be seen from the source code in Fig. 10, the main task of an operator function is to generate offsprings according to the values of Parent, where EAbinary() performs the single-point crossover in line 6–11 and the bitwise mutation in line 12–13 of the code. Afterwards, the INDIVIDUAL objects of the offsprings are generated and returned (line 14).

图10展示了基于二值编码（即，EAbinary.m）的演化算子的源码，其中算子函数的.m文件都是存储在\Opterators文件夹下的。一个算子函数有两个输入参数，一个表示GLOBAL对象（即，Global），另一个表示父族群（即，Parent），还有一个输出参数，表示生成的子代（即，Offspring）。可以从图10中的源代码看出，算子函数的主要任务，是根据Parent的值生成子代，其中EAbinary()在第6-11行进行单点交叉，在12-13行进行逐位变异。然后，生成并返回子代的INDIVIDUAL对象（14行）。

Fig. 11 shows the source code of IGD, where all these performance indicator functions are stored in the folder \Metrics. The task of a performance indicator is to calculate the indicator value of a population according to a set of reference points. The input parameters of IGD() consists of two parts: the objective values of the population (i.e. PopObj), and the reference points sampled on the true Pareto front (i.e. PF). Correspondingly, the output parameter of IGD() is the IGD value (i.e. score). Thanks to the merits of matrix operation in MATLAB, the source code of IGD is quite short as shown in Fig. 11, where the calculation of the mean value of the minimal distance of each point in PF to the points in PopObj can be performed using a built-in function pdist2() provided by MATLAB.

图11展示IGD的源代码，所有这些性能指示器函数都是存储于\Metrics文件夹下的。性能指示器的任务是，根据参考点集，计算一个族群的指示值。IGD()的输入参数由两部分组成：族群的目标值（即，PopObj），和在真实Pareto front中采样的参考点（即，PF）。对应的，IGD()的输出参数是IGD值（即，score）。多亏了MATLAB中矩阵运算的好处，IGD的源代码非常简洁，如图11所示，PF中的每个点，到PopObj中的点的最小距离的均值，可以使用MATLAB提供的一个内建函数pdist2()来进行。

### 4.4. Adding Acceptable Parameters for New Functions

All the user-defined functions can have their own parameters as well as the functions provided by PlatEMO, where these parameters can be either assigned by invoking main(…,’-X_parameter’,{…},…) with X denoting the function name, or displayed on the GUI for assignment. In order to add acceptable parameters for an MOEA, MOP, operator or performance indicator function, the comments in the head of the function should be written in a specified form. To be specific, Fig. 12 shows the comments and the source code in the head of the function of evolutionary operator based on real value coding (i.e. EAreal.m).

所有用户定义的函数，都可以有其自己的参数，PlatEMO提供的函数也是，这些参数可以通过调用main(…,’-X_parameter’,{…},…)来指定，其中X表示函数名称，或在GUI上显示以供指定。为给一个MOEA，MOP，算子或性能指示器加入可接受的参数，函数头的注释中要以特定的形式来写。具体来说，图12展示了基于实值编码的演化算子函数（即，EAreal.m）头部的注释和源码。

The comment in line 2 of Fig. 12 gives the two labels of this function, which are used to make sure this function can be identified by the GUI. The comment in line 3 is a brief introduction about this function; for an MOEA or MOP function, such introduction should be the title of the relevant literature. The parameters proC, disC, proM and disM for this function are given by the comments in line 4–7, where the names of the parameters are in the first column, the default values of the parameters are in the second column, and the introductions about the parameters are given in the third column. The columns in each row are divided by the sign ‘—’.

图12中第2行的注释，给出了这个函数的两个标签，用于确保函数可以被GUI识别。第3行的注释是函数的简要介绍；对于一个MOEA或MOP函数，这样的介绍应当是相关文件的标题。函数的参数proC，disC，proM和disM在注释的第4-7行给出，参数的名称在第1列，参数的默认值在第2列，参数的介绍在第3列。每一行中的列用符号---分割开来。

The comments define the parameters and their default values for the function, and invoking Global.ParameterSet() can make these parameters assignable to users. As shown in line 9 of Fig. 12, the function invokes Global.ParameterSet() with four inputs denoting the default values of the parameters, and sets the four parameters to the outputs. More specifically, if users have not assigned the parameters, they will equal to their default values (i.e. 1, 15, 1 and 15). Otherwise, if users assign the parameters by invoking main (…,’-EAreal_parameter’,{a,b,c,d},…), the parameters proC, disC, proM and disM will be set to a, b, c and d, respectively.

注释定义了函数的参数和其默认值，调用Global.ParameterSet()可以让这些参数对用户可指定。如图12中的第9行所示，函数调用了Global.ParameterSet()，有4个输入，表示参数的默认值，设这四个参数为输出。更具体的，如果用户没有指定这些参数，它们会等于其默认值（即，1，15，1，15）。另外，如果用户通过调用main (…,’-EAreal_parameter’,{a,b,c,d},…)指定参数，参数proC, disC, proM 和 disM会分别被设为a,b,c,d。

## 5. Conclusion and Future Work

This paper has introduced a MATLAB-based open source platform for evolutionary multi-objective optimization, namely PlatEMO. The current version of PlatEMO includes 50 multi-objective optimization algorithms and 110 multi-objective test problems, having covered the majority of state-of-the-arts. Since PlatEMO is developed on the basis of a light architecture with simple relations between objects, it is very easy to be used and extended. Moreover, PlatEMO provides a user-friendly GUI with a powerful experimental module, where engineers and researchers can use it to quickly perform their experiments without writing any additional code. This paper has described the architecture of PlatEMO, and it has also introduced the steps of running PlatEMO with and without the GUI. Then, the ways of adding new algorithms, problems, operators and performance indicators to PlatEMO have been elaborated by several cases.

本文介绍了基于MATLAB的演化多目标优化算法开源平台，名为PlatEMO。PlatEMO的当前版本包含了50个多目标优化算法，和110个多目标测试问题，覆盖了目前最好的主要部分。由于PlatEMO的开发是在轻架构的基础上，对象间的关系简单，很容易使用和拓展。而且，PlatEMO给出了用户友好的GUI，有强大的试验模块，工程师和研究者可以用其很快的进行试验，不需要写任何额外的代码。本文描述了PlatEMO的架构，还介绍了用和不用GUI运行PlatEMO的步骤。然后，用几个例子描述了向PlatEMO中加入新的算法，问题，算子和性能指示器的方法。

It is worth noting that, despite that we have performed careful validation and test on the source code of PlatEMO, there may still exist incorrect re-implementations or bugs. To address this issue, we have carefully followed the advice in dealing with algorithm implementations in [105]. We have performed unit tests on every algorithm in PlatEMO thoroughly, highlighted the source of the reusing code, and reported the version number and the change log on the website after each update as suggested in [105]. In addition, since all of the algorithms in PlatEMO are completely open-source, we sincerely hope that users of the software could also join us to make further improvements.

值得指出的是，尽管我们对PlatEMO的源码进行了仔细的验证和测试，但仍然可能存在不正确的重实现，或bugs。为解决这个问题，我们仔细的遵循了[105]中的算法实现的建议。我们对PlatEMO中的每个算法进行了单元测试，强调了重使用代码的源，在每次更新后，都给出了版本号，和change log。另外，由于PlatEMO中的算法是完全开源的，我们真诚的希望软件用户也可以加入我们做出进一步的改进。

We will continuously maintain and develop PlatEMO in the future. On one hand, we will keep following the state-of-the-arts and adding more effective algorithms and new problems into PlatEMO. On the other hand, more modules will be developed to provide more functions for users, such as preference optimization, dynamic optimization, noisy optimization, etc. We hope that PlatEMO is helpful to the researchers working on evolutionary multi-objective optimization, and we sincerely encourage peers to join us to shape the platform for better functionality and usability.

我们会在未来持续的维护并开发PlatEMO。一方面，我们会跟踪最新进展，向PlatEMO中加入更高效的算法和新问题。另一方面，会开发更多的模块，向永固提供更多功能，比如，倾向性优化，动态优化，含噪优化，等。我们希望PlatEMO对演化多目标优化的研究者是有帮助的，我们真诚的鼓励同行加入我们，形成平台更好的功能和可用性。