# New methodology for early-stage, microarchitecture-level power–performance analysis of microprocessors

D. Brooks et. al.

## 0. Abstact

The PowerTimer toolset has been developed for use in early-stage, microarchitecture-level power–performance analysis of microprocessors. The key component of the toolset is a parameterized set of energy functions that can be used in conjunction with any given cycle-accurate microarchitectural simulator. The energy functions model the power consumption of primitive and hierarchically composed building blocks which are used in microarchitecture-level performance models. Examples of structures modeled are pipeline stage latches, queues, buffers and component read/write multiplexers, local clock buffers, register files, and cache array macros. The energy functions can be derived using purely analytical equations that are driven by organizational, circuit, and technology parameters or behavioral equations that are derived from empirical, circuit-level simulation experiments. After describing the modeling methodology, we present analysis results in the context of a current-generation superscalar processor simulator to illustrate the use and effectiveness of such early-stage models. In addition to average power and performance tradeoff analysis, PowerTimer is useful in assessing the typical and worst-case power (or current) swings that occur between successive cycle windows in a given workload execution. Such a characterization of workloads at the early stage of microarchitecture definition helps pinpoint potential inductive noise problems on the voltage rail that can be addressed by designing an appropriate package or by suitably tuning the dynamic power management controls within the processor.

PowerTimer工具集的开发是用于早期微架构级的微处理器功耗-性能分析。工具集的关键组件是一个参数化的功耗函数集，可以与任何周期精确的微架构仿真器一起使用。功耗函数对各模块的功耗进行了建模，这些原始的层次化的模块也用在微架构级的性能模型中。建模的结构的例子包括，流水线级的latches，queues，buffers和组件读写multiplexers，局部时钟buffers，寄存器组，和cache阵列macros。功耗函数可以用纯解析等式推导出来，由组织的，电路和技术节点参数驱动，或由经验性的，电路级的仿真实验推导出的行为方程驱动。在描述了建模的方法后，我们给出分析结果，是对当前代的超标量处理器仿真器进行的建模，描述的是这样的早期模型的使用和效果。除了平均的功耗和性能折中分析，PowerTimer在对给定的workload执行中的后续周期窗口中典型的和最坏情况的功耗波动分析中是非常有用的。这种在微架构定义的早期对workload的特性进行分析，可以帮助确定可能的在电压方面带来噪声的问题，这些问题可以由设计合适的package，或合适的调整处理器内的动态功耗管理控制来处理。

## 1. Introduction

Power dissipation limits have emerged as a first-order design constraint for microprocessors. In fact, at the low end of the performance spectrum, that is, in the world of handheld and portable devices or systems, it is not unusual for power to dominate performance as the primary design constraint. Battery life and system cost constraints therefore force a microprocessor design team to consider power over performance. Increasingly, however, power is a key design aspect in the workstation and server market as well [1]. For high-end applications, increasing microarchitectural complexities, clock frequencies, and die sizes are pushing the chip-level (and hence, system-level) power consumption, literally to the edge. If designs continue to pursue a performance-centric, power-unaware approach, traditional air cooling for multiprocessor servers may soon have to be replaced by refrigeration or liquid cooling. This would cause a break point (with a step upward) in the ever-decreasing price–performance ratio curve. Hence, a modern microprocessor system design approach that takes into account power consumption and dissipation limits early in the design cycle and maintains a power-centric focus across all levels of design abstraction should have an edge over competing approaches.

功耗限制已经是微处理器的一阶设计约束。实际上，在性能系列的低端，即，在手持和可移动设备或系统的世界中，将功耗作为主要设计约束，而不是性能，这是很常见的。电池寿命和系统代价约束，迫使一个微处理器设计团队优先考虑功耗，而不是性能。而且，在工作站和服务器市场，功耗也越来越多的作为一个关键的设计方面。对于高端应用，越来越高的微架构复杂度，时钟频率，和die大小，正在将chip层次（因此也是系统层次）的功耗推向边缘。如果设计继续追求性能为中心，对功耗无感的方法，多处理器服务器传统的风冷很快就要被制冷或液冷方法替代。这会在持续降低的价格-性能比曲线上导致一个断点。因此，一个现代微处理器系统设计方法，将功耗限制放在设计周期的早期，在所有设计抽象层次上都维护功耗中心的焦点，应该会非常有竞争力。

Figure 1 shows a typical modeling and analysis tool flow in microprocessor design. There are variations in the flow and the exact levels of design description, depending on the product [e.g., high-end microprocessor, application-specific integrated circuit (ASIC) or embedded processor system, digital signal processor (DSP)]; however, the essential elements of the overall methodology are the same.

图1展示了微处理器设计中的典型的建模和分析工具流。随着产品的不同（如，高端微处理器，ASIC或嵌入式处理器系统，DSP），这些流程和设计描述的严格层次会有变化；但是，总体方法的关键元素是相同的。

At the very early stages of design definition, microarchitects start with analytical CPI (cycles-per-instruction) performance models that lead into trace or execution-driven, cycle-by-cycle simulators. Full or sampled benchmark traces are processed through such simulators, driven by a microarchitecture parameter file. The goal of this design space exploration phase is to optimize the choice of microarchitectural parameters for CPI performance under design constraints known at that stage. The performance model is typically written in a standard systems programming language such as C/C++, and is designed to project execution times (in cycles) for input application traces; it typically does not model the actual execution of the instructions, but only the execution timing. At the end of the high-level design phase, the register transfer level (RTL) model is developed using a hardware description language such as VHDL [VHSIC (very-high-speed integrated circuit) Hardware Description Language]. This model, when ready and validated, incorporates the full register-transfer-level functionality with accurate cycle-by-cycle timing flow behavior of the modeled machine. The main objective of developing this RTL model is to verify the functional integrity of the full logic-level description of the machine. For designs that are synthesized, the VHDL description is also used for generating a gate-level model as a precursor to the circuit-level refinement. For custom designs, the circuit-level netlist description is developed independently, in parallel with or after RTL coding, starting with schematic entry. Beyond the circuit netlist model, which is subject to timing verification and tuning, the design description is further refined into the physical design level, with layout, placement, and routing information included.

在设计定义的非常早期阶段，微架构师从分析CPI性能模型开始，这是trace驱动或执行驱动的，周期精确的仿真器。完整的或采样的benchmark traces，用这样的仿真器进行处理，其中包含一个微架构参数文件。这个设计空间探索阶段的目标是优化微架构参数的选择，在本阶段已知的设计约束下得到更好的CPI性能。性能模型一般是用标准系统编程语言，如C/C++，其设计是对于输入的应用traces，输出执行时间（以周期计）；一般来说，性能模型并不对指令的实际执行进行建模，而是对执行的时序进行建模。在高层设计阶段的最后，会使用硬件描述语言，如VHDL，开发出RTL模型。这个模型在准备好和验证后，会包含完整RTL功能，带有被建模的机器的精确的周期级时序流行为。开发这个RTL模型的主要目标，是验证机器完整的逻辑级描述的功能完备性。对于综合过的设计，VHDL描述也用于生成门级模型，作为电路级优化的先驱。对于定制化的设计，电路级网表描述是独立开发的，与RTL代码是并行的，或在其后，以schematic entry开始。电路网表模型是用于时序验证和调整，在此之外，设计描述进一步优化到物理设计层，带有布局，布线信息。

As the design model is refined from the highest level of abstraction to the lowest, the accuracy and detail of functional and timing information increase. Validation of the model at each level and between successive levels becomes more time-consuming and complex in proceeding down the design hierarchy. In current processor design, energy models are defined and used at virtually all levels of this hierarchy in order to include power as a constraint in the design optimization process.

随着设计模型从最高层抽象到最底层都优化结束，功能和时序信息的准确度和细节都在增加。在每个层次和相邻层次间模型的验证，随着设计层次向下，都变得更加耗时和复杂。在当前的处理器设计中，功耗模型在这个层次结构中的所有层次都有定义和使用，使功耗成为设计优化过程中的一个约束。

In this paper, we describe PowerTimer, initially introduced in [2], a toolset that is used for microarchitecture-level power–performance modeling. Although currently targeted for high-end microprocessors, its methodology should also be applicable to other domains (e.g., embedded or special-purpose microprocessor systems). PowerTimer uses a variety of sources for power models, such as output from a circuit-level power analysis and extraction tool or analytical models derived in a bottom-up modeling methodology. Microarchitecture-level energy models can be based on either A) technologically scaled projections from low-level (e.g., circuit-simulation-based, RTL-simulation-based, or actual hardware-measurement-based) energy characterization data available from previous designs; or B) analytical models that attempt to characterize the power on the basis of the implementation structure (at the gate level or circuit level with or without interconnect effects) of each microarchitectural entity or event (e.g., an issue queue entry or a cache access event). The models are in the form of equations driven by parameters available from a given CMOS technology.

本文中，我们描述了PowerTimer，最早在[2]中提出，这个工具集用于微架构级的功耗性能建模。虽然当前的目标是高端微处理器，其方法也应该可应用于其他领域（如，嵌入式，或特殊目的的微处理器系统）。PowerTimer使用多个源进行功耗模型，比如电路级功耗分析和提取工具的输出，或自底向上建模方法推导出的模型。微架构级的功耗模型可以基于：A)之前的设计中可用的底层（如，基于电路仿真，基于RTL仿真，或基于实际的硬件测量）数据的缩放；B)解析模型，试图在每个微架构实体或事件（如，issue队列entry，或cache访问事件）的实现结构（门级或电路级，带有或不带有互联效果）的基础上，刻画功耗的特征。模型是等式的形式，包含给定的CMOS技术节点的参数。

In Section 2, we describe the overall structure and operation of PowerTimer, with simple examples to illustrate how it is used in practice.

在第2节中，我们描述了PowerTimer的总体结构和操作，有简单的例子描述在实践中是怎样使用的。

Section 3 describes the generation of energy models that are used by PowerTimer. We include a brief description of Common Power Analysis Methodology (CPAM) [3], a circuit-level power analysis tool developed at IBM. We use this tool for deriving type-A energy models. We also describe the analytical modeling techniques for type-B energy models.

第3节中描述了PowerTimer中使用的功耗模型的生成。我们简单描述了常见的功耗分析方法(CPAM)，这是IBM中开发的电路级的功耗分析工具。我们使用这个工具来推导出type-A功耗模型。我们还描述了解析建模技术得到的type-B功耗模型。

In Section 4, we report specific examples of applications of PowerTimer, with experimental results and analysis. Section 5 covers related prior work in some detail. In Section 6 we provide a summary of the main content of this paper and a brief discussion of future work. In particular, we point to the need for developing robust pre-chip-fabrication silicon model validation methodologies that are appropriate for current early-stage tools such as PowerTimer. We refer briefly to prior approaches and explain how we plan to adapt and extend those techniques for PowerTimer.

在第4部分，我们给出了PowerTimer应用的具体例子，带有试验结果和分析。第5部分是之前的相关工作。第6部分，我们总结了本文的主要内容，简要讨论了未来的工作。特别是，我们指出了开发稳健的芯片制造前硅模型验证方法的必要性，适合于当前的早期工具，比如PowerTimer。我们简要的介绍了之前的方法，解释了我们怎样将这些技术调整拓展到PowerTimer。

## 2. PowerTimer: Overall structure and operation

Figure 2 is a block diagram of the PowerTimer toolset—currently in use during the early-stage definition of future high-end PowerPC processors. The base cycle-accurate performance simulator that is used depends on the target processor. For general research studies, we use the code base of an available parameterized simulation toolset designated as Turandot/MET [4]. (MET denotes a microarchitecture evaluation toolset, and Turandot denotes the cycle-accurate performance simulator within the MET.) A cycle-accurate simulator such as Turandot is capable of reading instructions from a program’s executable code (or a trace of the same) and simulating the timing flow within the target processor. Pipeline latencies, instruction flow bandwidths, and stall/flush occurrences (for example, in the case of cache misses and branch mispredictions) are all modeled as accurately as possible, with the goal of projecting the execution time (in processor cycles) of an input application program. The key new capability added to early-stage performance simulators in such a toolset is provided in the form of processor-specific energy models that can be used during the simulation run. The research microarchitecture power models (RMAP) function suite is designed to meet this need. An input file that defines the microarchitectural parameters for the base performance simulator also helps configure the associated unit-level energy functions. For example, the size, type, and configuration parameters defining an issue queue unit within the simulation model also determine the energy function to be called to compute power usage for that unit during the simulation run.

图2是PowerTimer工具集的模块图，在未来高端PowerPC处理器的早期阶段定义时，目前正在使用该工具集。目前在使用的周期精确性能仿真器，依赖于目标处理器。对于通用研究，我们使用一个可用的参数化的仿真工具集的代码，名为Turandot/MET。（MET表示微架构评估工具集，Turandot表示MET中的周期精确的性能仿真器）一个周期精确的仿真器，比如Turadot可以从程序的执行代码（或程序的trace）中读取指令，在仿真目标处理器中的时序流。流水线延迟，指令流带宽，和stall/flush的发生（比如，在cache miss和分支误预测的情况）都尽可能精确的进行建模，其目标是得到输入程序的执行时间（以处理器周期为单位）。对这个工具集中的早期性能仿真器，我们加入的关键的新能力，是随处理器而不同的功耗模型，可以在仿真运行的时候使用。研究微架构功耗模型(RMAP)函数包，其设计就是要满足这个需求。对基准性能仿真器，定义微架构参数的输入文件，也帮助配置了相关了的单元级功耗函数。比如，在仿真模型中，定义一个issue queue单元的大小，类型和配置参数，同时也决定了要调用的功耗函数，以计算在仿真运行时这个单元的功耗使用。

The other input to the RMAP suite is the set of circuit style and technology parameters that are specific to a particular target processor. Examples are latch types and the CMOS technology generation with associated voltage and scaling parameters.

RMAP包的其他输入，是具体到特定目标处理器时的电路类型和技术参数集合。例子包括latch类型，和CMOS技术代际，以及相关的电压，和缩放参数。

The RMAP suite can be used in two different modes: a) integrated and compiled into the simulator code for the functions to be called on a cycle-by-cycle basis, depending on the macros and units that are activated in a given simulation cycle; b) called once, using average unit usage statistics at the end of the simulation run. The integrated mode (a) allows cycle-by-cycle characterization of power, power–performance, and power swing (di/dt) metrics in a straightforward manner. The postprocessing mode (b) allows the computation of average power and power–performance data very efficiently, without significant slowing of the simulation.

RMAP包可以用到两种不同的模式中：a)集成并编译到仿真器代码中，这些函数可以在每周期执行的时候被调用，在给定的仿真周期中，有的宏和单元会被激活；b)在仿真运行的最后，调用一次，使用平均单元使用统计。集成模式(a)可以以直接的形式，对每周期的功耗，功耗-性能，和功耗波动(di/dt)度量进行刻画。后处理模式(b)可以非常高效的计算平均功耗和功耗-性能数据，仿真速度没有明显的下降。

Our goal of supporting multiple processor development projects naturally steered us to the requirement of designing the RMAP function suite in a manner that allows maximum flexibility and portability. At this time, we are working with customized, processor-specific energy functions for several target processors in development within IBM. However, on the basis of the experience that we gather from these design points, which differ significantly in functionality and performance, we are developing a parameterized, portable RMAP suite for use by other processor development groups within the company. In association with our research MET simulation toolset [4, 5], we also plan to release a generic, nonconfidential version of RMAP for use by our external, university research partners.

我们支持多处理器开发项目的目标，很自然的要求，在设计RMAP函数包的时候，要有最大的灵活性和可移植性。在这个时候，我们在IBM内部几个目标处理器的开发中，都在使用定制的，处理器特定的功耗函数。但是，我们从这些设计点上收集了很多经验，这些设计点在功能和性能上都差异很大，在此基础上，我们开发了一个参数化的可移植的RMAP包，可供公司内其他处理器开发组来使用。和我们的研究MET仿真工具集一起，我们计划放出一个通用的非保密版本RMAP，供外部，大学研究合作者使用。

The high-level pipeline structure of the parameterized Turandot/MET microprocessor model [5] is shown in Figure 3. The modeled microarchitecture is similar in complexity to that of a current-generation PowerPC processor [6, 7]. The model assumes an in-order front end in which, on a given cycle, the instruction fetch unit (IFETCH) accesses the level-1 instruction cache (L1 I-cache) to bring the next sequential group of instructions into the instruction buffer (I-buffer). The maximum number of instructions that can be fetched per cycle is a parameter that can be adjusted (like most of the other bandwidth parameters in the model). The decode/expand unit is a parameterized multicycle pipeline unit that decodes up to five instructions per cycle to form a basic dispatchable group (DG). Some complex instructions (e.g., a floating-point “store with update”) are “cracked” into two or more micro-operations in forming such a DG, which contains a maximum of five (micro)-operations. Since a branch instruction always causes a DG to terminate, a DG may contain from one to five (micro)- operations. After the register renaming and dispatch cycle(s), instructions from a DG are distributed into one of four different issue queues, depending on their operation types (e.g., integer, load/store, floating-point, or branch). Each instruction issue logic is implemented to support “out-of-order” issue of instructions into respective execution pipelines. Up to two instructions can be issued per cycle from each issue queue, after a “register read” pipeline cycle. The model supports out-of-order execution, with in-order retirement logic using a standard retirement queue (reorder buffer) mechanism. Other structures modeled are the various queues and buffers that are part of such out-of-order, superscalar processors. Separate next-fetch-address (NFA) predictor and two-level branch predictor mechanisms are supported. Turandot models an L1–L2 cache hierarchy, with split instruction and data L1 caches and a unified L2 cache. Instruction and data translation lookaside buffers (TLBs) are also modeled, along with the cast-out queue required to support a store-in caching mechanism for the L1 data cache. Main memory (L3) is modeled as an infinite, perfect storage with a constant (albeit parameterized) access latency.

参数化的Turandot/MET微处理器模型的高层流水线结构如图3所示。建模的微架构在复杂度上与当前的一个PowerPC处理器是相似的。模型假设前端是顺序的，在给定的周期中，取指单元(IFETCH)访问L1 I-cache，得到下一个顺序的指令组，拿到指令buffer(I-buffer)中。每个周期内可以拿到的最大数量的指令，是一个可以调整的参数（与模型中多数其他带宽参数类似）。译码/展开单元是一个参数化的多周期流水线单元，每周期可以解码最多5条指令，形成一个基本的可分派组(DG)。一些复杂的指令（如，浮点的store with update）会被分解为两条或多条微操作，形成这样的DG，最多包含5条这样的微操作。由于分支指令会导致DG中止，一个DG会包含1到5条微操作。在寄存器重命名和分派周期后，DG中的指令会根据其操作类型的不同（如，整数，load/store，浮点，或分支），被派到4个不同的发射队列中的一个。每个指令发射逻辑的实现，都要支持指令乱序发射，到分别不同的执行流水线上。在一个寄存器读流水线周期后，从每个issue队列，每周期可以发射最多两条指令。模型支持乱序执行，使用标准的retirement队列机制(reorder buffer)进行顺序retirement。建模的其他结构包括，各种队列和buffers，这是乱序超标量处理器的一部分。还支持分开的下一个fetch地址(NFA)预测器和两级分支预测器机制。Turandot建模了L1-L2 cache层次结构，L1 cache的指令和数据部分是分离的，L2 cache是统一的。指令和数据TLB也进行了建模，此外还有cast-out queue，可以支持L1 data cache的store-in caching机制。主存(L3)建模一个无限的，完美的存储，访问延迟为常数（也是参数化的）。

As described in [4], this research simulator was calibrated against a pre-RTL, detailed, latch-accurate processor model (referred to as the R-model in [4]). The R-model is a custom simulator, written in C++ (with mixed VHDL “interconnect code”). There is a one-to-one correspondence of signal names between the R-model and the actual VHDL (RTL) model; however, the R-model is about two orders of magnitude faster than the RTL model and is considerably more flexible. Many microarchitecture parameters can be varied, albeit within restricted ranges. Turandot, on the other hand, is a classical trace/execution-driven simulator, written in C, which is one to two orders of magnitude faster than the R-model. It supports a much greater number and range of parameter values.

如[4]中所述，这个研究仿真器与一个pre-RTL，详细的，latch准确的处理器模型（[4]中称之为R-model）进行了校准。R-model是一个定制的仿真器，用C++书写（与VHDL互联代码进行了混合）。R-model的信号名称和实际的VHDL (RTL)模型有一对一的对应关系；但是，R-model比RTL的速度快了接近2个数量级，而且更灵活。很多微架构参数可以变化，但是在有限制的范围内。Turandot是一个经典的trace/执行驱动的仿真器，用C写的，比R-model要快1-2个数量级，支持的参数数值和范围都要大的多。

In this paper, we report power–performance results using the same version of the R-model which was used in [5]. We first used our developed energy models in conjunction with the R-model: This ensured accurate measurement of the resource utilization statistics within the machine. To circumvent the simulator speed limitations, we used a parallel workstation cluster; also, we postprocessed the performance simulation output and fed the average resource utilization statistics to the energy models to obtain the average power numbers. Looking up the energy models on every cycle during the actual simulation run would have slowed the R-model execution even further. While it would have been possible to obtain instantaneous, cycle-by-cycle energy consumption profiles through such a method, it would not have changed the average power numbers for entire program runs.

本文中，我们使用[5]中相同的R-model，来给出功耗-性能结果。我们首先使用开发出的功耗模型与R-model结合到一起：这确保了机器内部资源利用统计的精确度量。为防止仿真器速度限制，我们使用了一个并行workstations集群；同时，我们对性能仿真的输出进行了后处理器，将平均资源利用率统计送入功耗模型，得到平均功耗数值。在实际仿真运行的时候，查找每个周期的功耗模型，会进一步降低R-model的执行速度。通过这样一种方法，这确实可以得到周期准确的功耗profile，但这不会改变整个程序运行时的平均功耗数值。

Having used the detailed, latch-accurate reference model for our initial energy characterization, we were able to examine the unit- and queue-level power numbers in detail in order to understand, test, and refine the various energy models. Currently, we have reverted to using an energy-model-enabled Turandot model for rapid CPI vs. power tradeoff studies with full benchmark traces. Turandot makes it possible to experiment with a wider range and combination of machine parameters.

使用详细的，latch准确的参考模型，刻画我们的初始功耗特征，我们可以详细检查单元级和队列级的功耗数值，以理解，测试和优化各种功耗模型。目前，我们回归到使用Turandot模型和功耗模型，进行迅速的CPI vs. 功耗折中，带有完整的基准测试trace。Turandot使其可能用机器参数更宽范围和更多的组合来进行试验。

## 3. Derivation of the Energy Models

In this section, we describe the methods used for deriving the RMAP energy function suite in PowerTimer. Several methodological paths are currently used to derive energy functions for use within the RMAP suite (see Figure 2).

本节中，我们描述了推导出PowerTimer中的RMAP功耗函数包所使用的方法。一些方法路径目前用于推导RMAP包中使用的功耗函数。

The first path, used in very early-stage (concept-phase) modeling, derives energy models on the basis of unit- and pipeline stage-level latch counts estimated by the design team. These latch counts are estimated from a) logic-level bit specifications of individual functions, where available; or b) area and latch-density based projections from prior designs, suitably scaled by technology upgrade parameters. Per-latch-bit power dissipation numbers are easily estimated or measured for the target technology, and clocked latches are known to account for 70 – 80% of unconstrained logic power in current processors. Hence, a latch-based energy model formulation for the non-array portions is often adequate during concept-phase microarchitecture definition.

第一条路径，在非常早期阶段（概念阶段）的建模中，在由设计团队估计出来的单元和流水线阶段级latch数量的基础上，推导出功耗模型。这些latch数量是由 a)每个功能的逻辑级的bit spec，b)基于面积和latch密度，从之前的设计进行投影，由技术升级的参数进行合适的缩放，进行估计的。每个latch-bit的功耗数值，对目标技术节点是很容易估计或测量的，有时钟的latches可以负责当前处理器中70-80%的未约束的逻辑功耗。因此，在非阵列部分，一个基于latch的功耗模型公式，在概念阶段的微架构定义中，通常是足够的。

The second path begins with detailed, macro-level power simulation data that is available from prior processor projects. This path is useful in formulating models for design macros that tend to be reused in newer designs with relatively small changes. This method of energy function generation is also appropriate during the early stages of the actual implementation phase when schematic-level descriptions of the circuit netlists are available for use in circuit-level characterization and tuning. The low-level power characterization data is generated using a research tool designated as CPAM [3]. A utility script converts the macro-level power data into higher-level, unit-specific energy functions appropriate for use by a microarchitectural simulator. Processor-specific scaling parameters (for size, configuration, circuit style, and technology) are used to configure the derived RMAP functions in an appropriate manner. Figure 4 depicts the derivation of the energy models in more detail.

第二个路径以详细的，macro级的功耗仿真数据开始，从之前的处理器项目中是可用的。这条路径在设计的marcos在新设计中会重用，改变很小的时候，形成模型的时候是很好用的。这种功耗函数生成的方法，在实际实现的早期阶段中也是合适的，这时schematic级的电路网表描述，在电路级的特征刻画和调节中也是可用的。底层功耗特征数据，使用一种研究工具生成，称为CPAM。一种工具脚本，将macro级别的功耗数据转换成更高层的，单元特定的功耗函数，可以由微架构仿真器使用。处理器特定的缩放参数（大小，配置，电路类型，和技术节点）用于以更合适的方式配置推导出的RMAP函数。图4详细展示了功耗模型的推导。

The energy models are based on circuit-level power analysis that has been performed on structures used in a recent high-performance IBM PowerPC processor, the IBM POWER4* [7]. The power analysis has been performed at the macro level; generally, multiple macros combine to form one microarchitectural-level structure which we designate as a subunit. For example, the fixed-point issue queue (one subunit) might contain separate macros for storage memory, comparison logic, and control. Power analysis has been performed on each macro to determine its power as a function of the input (i.e., macro input data/control pins) switching factor (SF). The HoldPower, or power when no switching is occurring, is also generated. These two pieces of data allow the formation of simple (albeit idealized) linear equations for the power of each macro. In general, for the ith of N macros that make up the microarchitectural unit being modeled, the power equation is modeled (from available CPAM data) as the linear equation

功耗模型是基于电路级的功耗分析，在最近的高性能IBM PowerPC处理器，IBM Power4*中，已经进行了使用，对其中的结构进行了分析。功耗分析是在macro级别；一般来说，多macros结合起来，形成一个微架构级的结构，我们表示为一个subunit。比如，定点issue queue（一个subunit）可能包含分离的macros，包含存储内存，比较逻辑和控制。功耗分析在每个macro上进行，确定其power是输入（即，macro输入数据/控制pins）切换因子(SF)的的函数。HoldPower，即没有Switching发生的功耗，也进行了生成。这两种数据允许两种macro的功耗的简单线性方程的生成。一般来说，对于建模的组成微架构单元的N个macros的第i个，功耗等式建模为下面的线性方程

$$Power(i) = (C_i × SF) + HoldPower(i)$$

where C_i is a macro-dependent constant that defines the slope of a straight line, assuming the x and y axes to be SF and Power(i), respectively. The energy model for a subunit is determined by essentially “summing” the linear equations for each macro within that subunit. This results in an overall linear power equation for the whole microarchitectural unit, with unit-level HoldPower equal to the HoldPower(i) summed over all macros that make up that unit. The slope of the resulting straight line is currently computed as a simple arithmetic mean of the individual C_i s. This is clearly an approximation; such averaging of the slopes should ideally be done by using appropriate weights for each component macro. The weight is (relatively) larger if the sensitivity to the input switching factor of that macro is (relatively) greater than the sensitivity to the input switching factor of the overall unit. Determination of the correct weights using empirical circuit-level experiments for large microarchitectural units is very time-consuming; hence, in the initial version of PowerTimer, the CPAM-based energy models assume equal weights for component macros within a given unit. Initial results in our ongoing power–performance validation studies (see Section 6 for a brief methodological description), indicate that this assumption does not have any significant impact on the relative accuracy of any useful microarchitecture-level tradeoff experiment.

其中假设x和y轴分别SF和Power(i),C_i是一个依赖于macro的常数，定义了直线的斜率。一个subunit的功耗模型，是将subunit中每个macro的线程方程相加得到的。这会得到整体微架构单元的线性功耗方程，单元级的HoldPower等于HoldPower(i)，是将这个unit中所有macro相加得到的。得到的直线的斜率，目前计算为单个C_i的简单的几何平均。这显然是一个近似；这样的斜率的平均，在理想的情况下，应当对每个组件macro使用近似的权重。如果输入Switching factor对这个macro的敏感度，比对整体单元的输入Switching factor的敏感度要高，那么其权重就应当相对要大一些。使用经验的电路级试验，来确定正确的权重，对大型架构单元，是非常耗时的；因此，PowerTimer的初始版本，基于CPAM的功耗模型，假设对于一个给定单元的组件macro是有相等的权重的。在我们正在进行的功耗-性能验证研究中，初始结果表明，这个假设对任何有用的微架构级的折中试验，并没有任何相对准确率的明显影响。

We have generated these power models for all microarchitecture-level structures (subunits) modeled in our research simulator [5]. In addition to the models that specify the power characteristics for particular subunits (such as the fixed-point issue queue), we can derive power models for more generalized structures: for example, a generalized issue queue model. These parameterized models are useful for estimating the power cost of additions to the baseline microarchitecture. The generalized model is derived by analyzing the power characteristics of similar structures within the baseline microarchitecture. For example, the fixed-point, floating-point, logical-op, and branch-op issue queues have very similar functionality and power characteristics and have been used to derive a generalized issue-queue power model based on parameters such as the number of entries, storage bits, and comparison operations. CMOS-technology-related power scaling is done using a simple CV^2f formulation. Voltage and frequency targets of the new processor design point are known from design specifications, and capacitance scaling is carried out using known dimension-scaling factors (for example, the factor of 0.7 that is usually selected to scale linear dimensions in going from one generation to the next [8]). These scaling factors can change somewhat, depending on the prior and target technology generation and perhaps even the target operating voltage or frequency; we act in consultation with the relevant design team and technology experts in using the best known technological scaling factors for use in PowerTimer.

我们对在我们研究的仿真器中建模的所有微架构级的结构(subunits)，都生成了功耗模型。除了对特定subunits指定了功耗特性的模型（比如，定点issue队列）以外，我们可以对更一般化的结构推导出功耗模型：比如，一般化的issue queue模型。这些参数化的模型对估计对基准微架构的功耗代价是有用的。一般化的模型是通过分析在基准微架构中的类似结构的功耗特性推导得到的。比如，定点，浮点，逻辑操作，和分支操作发射队列有着类似的功能和功耗特性，基于entries数量，存储bits数量，和对比操作的参数，可以推导出一般化的issue queue功耗模型。CMOS技术相关的功耗缩放是使用简单的CV^2f公式来进行的。新的处理器设计点的电压和频率目标，从设计spec中是已知的，电容的缩放是使用已知的维度缩放因素（比如，在从一代到下一代的设计中，通常选择线性缩放维度因子0.7）。这些缩放因素可能会有一些改变，依赖于之前的和目标技术代，甚至可能依赖于目标操作电压或频率；我们会咨询相关的设计团队和技术专家，在PowerTimer中使用知道的最好的技术缩放因子。

Since we are interested in determining the power–performance tradeoff for future microarchitectures within a given product family, we must devise a method of scaling the power of microarchitectural structures as the size of these subunits increases. The scaling factor that is used is dependent on the particular structure; for example, the power of a cache array scales differently from that of an issue queue. In addition, as resources increase in size, they necessarily cause other structures to become larger. For example, as the number of rename registers increases, the number of tag bits within each entry of the issue queue increases. Generally, as we increase the number of entries in a structure, there is a proportional increase in the power. For this reason, we use linear scaling as a basis for many of the structures that we consider. In addition, we have performed detailed analysis on the scaling of queue and mapper structures. For these structures, we have determined the average power per storage bit and per comparison operation. As the queues and mappers increase in size, we compute the number of storage bits and comparisons that occur for the larger structures. We also use previously published work on power scaling within cache arrays, which we discuss in Section 4.

我们感兴趣的是，在给定的产品线中，确定未来微架构的功耗性能的折中，所以我们设计出一种方法，随着这些subunit的大小增加，缩放微架构结构的功耗。使用的缩放因子，依赖于特定结构；比如，一个cache阵列的功耗的缩放，与一个issue queue的是不一样的。此外，在资源随着大小增加时，肯定会导致其他结构也会变得更大。比如，随着rename寄存器的数量增加，issue queue中的每个entry中的tag bits的数量也会增加。一般来说，随着我们增加一个结构中的entries数量，功耗是呈比例增加的。为此，我们使用线性缩放，作为很多结构的基础。对这些结构，我们确定了对每个storage bits和每个比较操作的平均功耗。随着队列和Mappers的规模增加，我们计算对大型结构中存储bits数量和发生的比较数量。我们之前还发表了关于cache阵列中功耗缩放的文章，在第4部分有进行讨论。

The third methodological path of energy model generation in PowerTimer (referring again to Figure 2) begins with newer circuit-simulation experiments to characterize latch types, clock buffers, and macros that are new and therefore not available from prior project data sets. With the anticipated use of clock-gating modes in future processors, the need to characterize the primitive energy characteristics (with and without clock gating) for the various latch types and associated local clock buffers is of paramount importance. This style of clocking and associated control logic is relatively new in IBM high-end processor development projects and therefore requires careful characterization at the circuit level. We have developed a methodology that uses PowerSpice-based detailed circuit-simulation experiments to obtain empirical energy data for primitive building blocks such as latches, clock-buffers, multiplexors, and interconnect (wiring) logic; analytical equations that have high-level organizational and technology parameters as arguments are formulated to model various combinations and sizes of the primitive blocks as they are used to design structures such as queues and buffers.

PowerTimer中功耗模型生成的第三条方法路径，以更新的电路模拟试验来刻画latch类型，时钟buffers和macros进行，这些是新的，所以之前的项目数据集中是不存在的。在未来的处理器中会用到时钟门控模式，所以对各种latch类型和相关的局部时钟buffer刻画原始的功耗特征（带或不带时钟门控），是非常重要的。这种时钟类型和相关的控制逻辑，在IBM的高端处理器开发项目中相对较新，因此需要在电路级仔细刻画。我们有一种方法，使用基于PowerSpice的详细电路仿真试验，来对原始模块得到经验功耗数据，比如latches，时钟buffer，multiplexors，和互连逻辑；有高层组织和技术参数作为参数的解析方程，用于建模原始模块的各种大小和各种组合，以用于设计结构比如队列和buffers。

The fourth path to derive RMAP energy functions (Figure 2) is an independent, analytical formulation methodology. We are currently experimenting with analytical energy equations for regular structures such as SRAM array macros. The Array Power Analysis (ARPA) tool has been developed with the goal of modeling the energy and delay characteristics of IBM-specific SRAM array designs that implement cache macros. This tool is currently under validation, with reference data for specific SRAM designs obtained from prior designers. Prior to the availability of a tuned, calibrated, and validated ARPA model for predictive use in our modeling work, we are relying on designer-provided energy models for customized SRAM array macros.

推导RMAP功耗函数的第4条路径，是独立的，解析公式的方法。我们目前用解析功耗方程对常规结构进行试验，如SRAM阵列macros。开发了阵列功耗分析(ARPA)工具，目的是对IBM特有的SRAM阵列设计进行功耗和延迟特性的建模，实现了cache macros。这个工具目前正在进行验证，参考数据是之前的设计得到的特定SRAM设计。我们目前依赖的是设计者提供的功耗模型，用于定制的SRAM阵列macro，未来会有调试好的，修正好的，验证好的ARPA模型。

### 3.1 Scaling and fine-tuning the energy models

An aspect of modeling that is dealt with in scaling macro-level energy data obtained from the analysis of previous designs to form energy models for use in future processors is repipelining [2]. This is necessary to reflect the impact of changes in pipeline depth of execution unit pipes (e.g., the floating-point unit or load-store unit pipe), and the corresponding increase in latch counts. For example, in going from an m-stage pipeline to an n-stage pipeline (m < n), we require the use of a suitable “repipelining” transformation to account for the larger latch counts in the latter design. Such a repipelining function must take into account the logic “shape function” that profiles the bit width variation with levels of logic in a given hardware function.

建模工作的一个方面，是处理从之前的设计得到的macro级别的功耗数据的缩放，形成未来处理器中的功耗模型，这个方面正在重塑。在执行单元（如，浮点单元，或load-store单元流水）流水线的深度的变化影响的反应上，和latch数量的对应增加上，这是必须的。比如，在从m级流水线变到n级流水线时(m < n)，我们需要使用合适的重塑变换，来将后者设计的更多的latch数量纳入考虑。这样一个重塑函数，必须要纳入考虑逻辑的shape function，在给定的硬件功能中，对逻辑层次上的bit宽度变化进行了profile。

Another aspect pertains to modeling the variation of power usage of a given resource as a function of its size parameters. For example, we need to know how the power consumption of an array structure (such as a branch history table) or a queue structure (such as an out-of-order issue queue) would vary with the number of entries. Using multiple macro data points from previous designs to characterize queues of different units in a prior design, one solution is to extrapolate to obtain the power characteristics of a generic queue structure in some cases. An alternative is to use newer “per-latch,” “per-entry,” or cross-sectional array data available from more recent circuit simulation experiments conducted by us or by our colleagues. A more generic approach is to resort to analytical models based on the analysis of cross sections and design templates for the design of a variety of queue, register file, and other array-like regular structures.

另一个方面是，将给定资源的功耗的变化，建模为其大小参数的函数。比如，我们需要知道，一个阵列结构的功耗（如，一个分支历史表），或一个队列结构的功耗（如，一个乱序issue队列），会随着entries的数量变化。使用之前设计的多个macro数据点，来刻画之前设计的不同单元的队列，一种解决方法是外插，得到一般性的队列结构的功耗特征。一种替代方法是，使用更新的per-latch，per-entry，或跨截面的阵列数据，可以从最近的电路仿真试验中得到。一种更一般性的方法，是利用解析模型，来为队列，寄存器组和其他阵列类的常规结构，设计出模板。

A third aspect pertains to the use of reasonable switching factors for individual macro logic entities within the modeled processor. In classical trace-driven simulation, data values in registers or data path logic are often ignored; only the cycle-by-cycle timing behavior is modeled. This precludes the determination of accurate data bit vector switching factors during simulation. Thus, although unit usage frequencies are accurately modeled, the data switching factors on a given use of a resource are often not accurately modeled in early-stage simulators. The use of execution-driven mode in the base simulation is one way of factoring the data switching factor information accurately. This mode is also needed to model the power overhead of speculative waste in an accurate manner.

第三个方面，是对建模的处理器中单个macro logic实体使用合理的Switching factors。在经典的trace驱动的仿真中，寄存器或数据通路逻辑中的数据值经常被忽略；只对周期级的时序行为进行建模。这根本无法确定仿真中的准确的数据位向量Switching factors。因此，虽然单元使用频率得到了精确的建模，在早期仿真器中，资源的特定使用中的数据Switching factors并没有准确的进行建模。在基准仿真中，使用执行驱动模式，是准确得到数据Switching factor信息的一种方法。在对推测损耗的功耗代价准确建模中，这种模式通常是必须的。

Of course, the use of technology-specific scaling factors to estimate power and area shrink factors for given macros may have the greatest impact on the accuracy of derived RMAP functions. The device models for future deep submicron technologies are still volatile in some cases, and the use of approximate scaling factors in early-stage modeling can lead to significant estimation errors. In this context, particular mention must be made of estimation of various forms of leakage power for future designs. This aspect of predictive extrapolation models is especially error-prone and therefore of concern in our modeling research.

当然，使用技术特定的缩放系数，来对给定的macros估计功耗和面积缩小因子，对推导RMAP函数的准确性有最大的影响。未来的亚微米技术的设备模型，在一些情况下仍然是不稳定的，在早期建模中，使用近似的缩放因子，可能会导致显著的估计误差。在这个上下文中，必须进行特殊的声明，估计未来设计中各种形式的漏功耗。这种预测性外插模型是非常容易出错的，因此是我们未来建模研究中的一个考虑。

There are clearly several different sources of error that make the estimation of power consumption a difficult task during the initial design phases. However, our goal is to provide a facility for making relatively accurate early-stage power and performance tradeoffs. For example, we wish to quantify the power savings potential with the use of fine-grain, pipeline-stage-level clock gating. We are less interested in the absolute accuracy of the power projections (with or without clock gating). Also, we are interested in projecting optimal issue widths and pipeline depths in concept-phase analysis under given definitions of power–performance efficiency metrics. For such metrics, the PowerTimer/RMAP methodology allows us to rank and compare different microarchitectural ideas that are proposed in early design stages.

在初始设计阶段进行功耗估计，有几个很明显的误差来源，这使功耗估计非常困难。但是，我们的目标是提供一个工具，对早期的功耗和性能折中，进行相对准确的估计。比如，我们希望量化功耗节省的潜力，使用细粒度，流水线级的时钟门控。我们对功耗映射的绝对准确率没有那么感兴趣。同时，我们感兴趣的是，在概念阶段分析中，在给定的功耗-性能效率度量时，给出最佳的issue宽度。对这样的度量，PowerTimer/RMAP方法，使我们可以对在早期设计阶段提出的不同的微架构想法进行排名和比较。

Validation and tuning of the energy models in the context of their use in early-stage power–performance tradeoff analysis is an ongoing task that we expect will be continued for the duration of future processor development projects. Our prior performance model validation methodology (see, e.g., [5]) is being augmented to cover validation of power–performance models. Also, we are designing a set of circuit-level test designs in support of a high-performance processor test chip that should allow us to calibrate our energy models for key structures (such as latches, issue queues, pipelined arithmetic units, and buffers) against measurements made at the RTL level and eventually at the hardware level.

在早期功耗-性能折中分析中，验证和调整功耗模型，这是一个不断进行的工作，我们希望在未来的处理器开发项目中可以不断进行。我们之前的性能模型验证方法进行了扩充，以支持功耗-性能模型的验证。同时，我们正在设计电路级测试设计集，以支持高性能处理器测试芯片，使我们可以对关键结构校准我们的功耗模型（比如latches，issue队列，流水线代数单元，和buffers），和在RTL级的测量比较，最终和硬件级的测量比较。

## 4. Using PowerTimer to design power-efficient high-performance processors

### 4.1 Data cache size and the effect of scaling techniques

### 4.2 Number of completion buffers

### 4.3 Ganged sizing

### 4.4 Analysis of pipeline optimization for power and performance

### 4.5 Other uses of PowerTimer in early-stage definition and design

## 5. Related prior work

From the viewpoint of functional usage, PowerTimer is similar to prior academic research tools such as Wattch [21, 22] and SimplePower [23], or tools developed in other companies, such as the research tool TEM2P2EST [24] or the ALPS simulator [25] used in the Intel Pentium 4 design. However, each of these microarchitecture-level power simulation tools uses a different methodology for generating the energy models; and, of course, the base performance simulation models that are in use with the energy models are also different in terms of the architecture (ISA), the family of microarchitectures, and the level of detail.

从功能使用的视角，PowerTimer类似于之前的学术研究工具，比如Wattch和SimplePower，或在其他公司开发的工具，比如研究工具TMP2P2EST或在Intel Pentium 4 design中使用的ALPS仿真器。但是，这些微架构级的功耗仿真工具，每个都使用了不同的方法学来生成功耗模型；当然，和功耗模型一起使用的基础性能仿真模型，在ISA，微架构族，和细节层次上都是不同的。

Wattch is the most widely used research power–performance simulator within the academic community. The base performance simulator in Wattch is the well-known SimpleScalar toolset [26]. The energy models derived for use in Wattch, broadly speaking, comprise two categories: a) analytical equations, modeling specific circuit classes—e.g., SRAM (static random-access memory) and CAM (content-addressable memory) structures, clocking networks, and issue queues; b) technologically scaled power numbers derived from published values for irregular logic structures that are hard to analyze—e.g., functional unit (ALU) blocks. The analytical equations are controlled by technology-specific per-unit-length capacitance values for metal, gate, and diffusion layers and structural geometry parameters of the modeled entity.

Wattch是最广泛使用的学术界研究用功耗-性能仿真器。Wattch中的基础性能仿真器是著名的SimpleScalar工具集。Wattch中使用的功耗模型，广泛的说，包含两种类别：a) 解析方程，建模特定的电路类别，如，SRAM，CAM结构，时钟网络，和发射队列；b) 对很难分析的不规则逻辑结构，如功能单元(ALU)模块，从发布的值中技术上缩放得到的功耗。解析的方程，是由技术特定的每个单元长度的电容值控制，包括金属，门控，和扩散层，和建模实体的结构几何参数。

As in the case of Wattch, the TEMPEST tool uses SimpleScalar as the base performance model. Again, the energy models are either analytical equations (for regular structures) or empirically derived from available data. The empirically derived models are based on power density and area estimates.

在Wattch的情况中，TEMPEST工具使用SimpleScalar作为基准性能模型。功耗模型是解析方程（对于规则的结构），或是从现在可用数据中通过经验推导出来的。通过经验推导出的模型，是基于功耗密度和面积估计的。

SimplePower uses state-transition-based energy usage models to capture detailed switching-dependent power variations in given logic blocks. Thus, for a given ALU macro, detailed circuit simulation-based energy data is gleaned for many (and ideally all) possible cycle-to-cycle transition patterns on the input pins. These energy values are stored in a lookup table, which is accessed to compute state transition-specific energy usage during execution-driven performance simulation. In this methodology, there is an issue concerning the very large sizes of energy lookup tables; however, the authors of [23] have developed methods for reducing the table sizes through collapsing of equivalent state transition entries.

SimplePower使用的是基于状态迁移的功耗模型，在给定的逻辑单元中捕获详细的依赖于switching的功耗变化。因此，对于给定的ALU macro，对输入pins的很多可能的周期迁移模式（理想情况下是所有的），收集详细的基于电路仿真的功耗数据。这些功耗值存储在一个查找表中，在执行驱动的性能仿真时，计算状态迁移特定的功耗时进行访问。在这种方法中，功耗查找表会很大，这是一个问题；但是，[23]的作者提出了方法，通过折叠等价的状态迁移entries，可以减小表格的规模。

The Intel architecture-level power simulator (ALPS) is built around a proprietary, Pentium-4-specific microarchitectural simulator. The energy models for microarchitectural blocks are derived from empirical energy data available from prior processors.

Intel的架构级功耗仿真器(ALPS)是在Pentium-4特定的微架构仿真器上构建起来的。微架构模块的功耗模型，是从之前的处理器中可用的经验功耗数据推导出来的。

PowerTimer, in contrast, uses a phased (hierarchical) suite of energy functions (RMAP) that are refined as the design and simulation model evolves. In the very early stages (concept phase), simple latch-count-based models are used for the logic; and per-port, per-access estimated power numbers are used for array and register file macros. As the design progresses, analytical equations derived from empirical power data for primitive building blocks are used for newer circuit structures within the target structure. When detailed circuit schematics are available, accurate circuit- simulation-based (CPAM) energy data is collected for each macro and abstracted for use in forming energy models for microarchitectural blocks. On occasion, prior-generation CPAM data is also used (after scaling) to form energy models for units that have not yet been characterized in the new design environment.

对比起来，PowerTimer使用的是一种阶段的（层次化的）功耗函数(RMAP)包，随着设计和仿真模型的演进，来进行优化。在非常早期的阶段（概念阶段），简单的基于latch数量的模型可以用于逻辑电路；对于阵列和寄存器组的macros，则使用估计的per-port，和per-access功耗数值。随着设计的演进，对原始部件使用经验功耗数据推导出的解析方程，用在目标结构中更新的电路结构中。当详细的电路图可用时，对每个macro收集准确的基于电路仿真的(CPAM)功耗数据，在对微架构模块形成功耗模型时进行抽象使用。有时候，前一代的CPAM数据也会在缩放后用于形成新模块的功耗模型。

## 6. Model validation and other future work

The use of early-stage, workload-driven power analysis tools (such as PowerTimer) is relatively new in industrial application, and a number of issues remain open for further research and development. One of the obvious issues is that of model validation. Since current-generation processors are not instrumented to monitor power consumption on a unit-by-unit basis, it is not yet possible to directly validate model-predicted power profiles against measured ones. Pre-silicon validation of function is a mature field (e.g., [27, 28]); testing, calibration, and validation of pre-silicon performance models have been addressed in recent work (e.g., [5, 29]), but it is still an evolving field. The Wattch project at Princeton [21, 22] addresses the issue of validating power models by comparing analytically modeled capacitances against post-layout-extracted ones. Also, the issue of absolute versus relative accuracy in models that use abstractions in selected power or performance submodels within a simulator has been addressed in recent work [22, 30]. We are currently pursuing further research in establishing pre-silicon reference models on expected power bounds for given architectural test cases. This is an extension of prior work that was limited to performance (CPI) bounds [5, 31]. This research should lead us into formalizing a systematic, parameter-driven test case generation methodology—one that should allow a design team to generate a suite of test cases with a priori bounds on cycle-count (or CPI), unit utilizations, and power.

使用早期的，workload驱动的功耗分析工具（比如PowerTimer）在工业应用中是相对较新的，有一些问题需要未来进行研究和开发。一个明显的问题是模型验证。由于当前代的处理器并不能监控单元的功耗，所以现在不可能直接将模型预测的功耗profiles和测量的功耗进行验证。功能的硅前验证是一个成熟的领域；硅前性能模型的测试，校准和验证，最近有一些工作，但仍然是一个正在演进的领域。Princeton的Wattch项目处理的是功耗模型的验证问题，将解析建模出来的capacitance与布局后提取出的进行比较。有一些模型在仿真器中使用的一定的功耗或性能子模型的抽象，这些模型中的相对准确率与绝对准确率的问题也有一些工作。我们在对给定的架构测试case，在期望的功耗期望上，确定硅前参考模型中，正在进行进一步的研究。这是之前工作的一个拓展，以前只局限于性能(CPI)的功能。这些研究可以得到一个系统的，参数驱动的测试case生成方法，设计团队可以生成一些测试cases包，并对CPI，单元利用率和功耗，有先验的界限。

The basic idea in this approach is to statically estimate the bounds on CPI and unit-level average utilizations for given architectural test cases. Lower bounds on CPI for loop-oriented test cases can be analytically estimated by assuming infinite queue and buffer sizes and then deducing the performance-limiting bandwidth parameter for the given test case [31]. For example, if a loop is provably memory-bound, a lower bound on cycles per loop iteration is obtained by dividing the total number of load and store instructions in the loop by the number of load-store units, or by the number of cache ports, whichever is smaller. Our power–performance model validation procedure goes one step beyond this by deducing the various queue, cache, and pipeline stage utilization bounds using analytical models. Since unit utilizations can be transformed to power numbers through suitable weighting functions, we effectively have a method of deducing power and performance bounds for given loop test cases. If measured (simulated) power and performance, under appropriate parametric settings of the model, violate the analytically derived bounds, we detect a model defect. We are currently engaged in completing this work, which will be reported separately in a forthcoming publication.

这些方法中的基本思想是，对给定的架构测试案例，静态的估计CPI和单元级的平均利用的界限。对循环向的测试案例，可以假设无线的队列和buffer大小，解析的估计CPI的下界，然后对给定的测试案例推导出限制性能的带宽参数。比如，如果一个循环可以证明是内存受限的，将循环中load和store指令的总数，除以load-store units中的数量，或除以cache ports的数量，其中较小的值，就是cycles per loop iteration的下限。我们的功耗-性能模型验证过程做的更多一些，推导各种queue，cache，和流水线阶段的利用界限，使用的是解析模型。由于单元利用率可以通过合适的权重函数变换成功耗数值，我们立刻就有了对给定的循环测试cases推导出功耗和性能界限的方法。如果测量的（仿真的）功耗和性能，在模型合适的参数化设置下，与解析推导出的界限相违背，我们就检测出了一个模型缺陷。我们目前正在完成这个工作，会在未来的文章中报告。

In carrying out this validation work, our emphasis, as stated before, is on relative accuracy. We believe that the primary goal of microarchitecture-level models such as PowerTimer is to guide the early-stage-design architects so that the fundamental microarchitectural design parameters, such as pipeline depth, instruction issue width, cache sizes, queue sizes, and basic latency and bandwidth parameters, are chosen correctly from the viewpoint of power–performance balance. In our current pipeline-level energy scaling models (as described in the section on analysis of pipeline optimization for power and performance), we do not consider the circuit-level power–performance optimization choices available to the designer on a per-stage basis. In future work, we may incorporate such additional design space exploration choices (e.g., see the paper by Zyuban and Strenski in this issue [13]) within the PowerTimer framework.

在进行这种验证工作中，我们强调的是相对准确率。我们相信，微架构级别的模型，比如PowerTimer，的主要目标，是引导早期阶段设计的架构师，这样，基本的微架构设计参数，如流水线深度，指令发射宽度，cache大小，queue大小，和基本的延迟，和带宽参数，是从功耗-性能平衡的视角中，正确的进行选择的。在我们当前的流水线级的功耗缩放模型中，我们没有逐阶段考虑电路级的功耗-性能优化选择。在未来的工作中，我们可能早PowerTimer框架中加入额外的设计空间探索选项（如[13]）。

In other work, we are currently extending the definition of our power models into a hierarchical, modular library format. When completed, this power function library will allow us to construct and use energy models in various stages of design (e.g., in very early stages, we can use simple latch- or area-based energy models and analytical formulations), while in later stages we can build more detailed models based on parameterized, circuit-level characterizations of primitive building blocks targeted for use in a given design.

在其他工作中，我们正在将我们的功耗模型的定义拓展，成为一个层次化的，模块化的库的格式。当完成后，这个功耗函数库就可以用于在设计的各阶段中构建和使用功耗模型，如在非常早期的阶段中，我们使用简单的基于latch的或基于面积的功耗模型和解析公式，后面的阶段中，我们可以构建更详细的模型，基于参数化的电路级的原始模块的刻画。

The base Turandot model is currently being significantly overhauled and updated in order to make it much more user-friendly and modular, with the addition of microarchitectural features such as simultaneous multithreading (SMT) and support for various types of “in-order” issue mechanisms. Correspondingly, the associated power models are also being augmented. We plan to report the updated and fully validated PowerTimer-II modeling and analysis results in future publications.

基础的Turandot模型目前正在大修和更新，以使其更加用户友好，更加模块化，加入了新的微架构特征，比如SMT，和支持各种类型的顺序issue机制。对应的，相关的功耗模型也在进行扩增。我们计划在未来给大家汇报更新的，完全验证的PowerTimer-II建模和分析结果。

## 7. Summary

We have described the PowerTimer toolset that is currently in use to facilitate early-stage power–performance analysis and microarchitecture definition of high-end, general-purpose IBM PowerPC processors. PowerTimer uses a variety of sources for power models, such as output from a circuit-level power analysis and extraction tool or analytical models derived in a bottom-up modeling methodology.

我们描述了PowerTimer工具集，目前正用于促进高端的，通用目标的IBM PowerPC处理器的早期功耗-性能分析和微架构定义。PowerTimer使用各种源进行功耗建模，比如电路级功耗分析的提取工具的输出，或自底向上的建模方法推导出的解析模型的输出。

Early-stage power–performance modeling is now a critical aspect of future processor design. Future processor cores continue to have aggressive performance goals, but they are now facing tight power budgets and power-density limits. In previous processor generations, such as the IBM POWER3* [6] and POWER4* [7], early-stage definition studies did not require a systematic analysis of power because associated estimated increases in power dissipation were still comfortably below the limits dictated by the packaging/cooling solutions appropriate for high-end PowerPC workstations and servers.

早期的功耗-性能建模，是未来处理器设计的一个关键部分。未来的处理器核会一直有很激进的性能目标，但是目前正面临着功耗预算和功耗-密度的限制。在之前的处理器中，比如IBM Power3和Power4中，早期定义的研究，不需要系统的分析功耗，因为相关的功耗的估计的增加，仍然远低于封装/散热方法的限制。