# Using SimPoint for Accurate and Efficient Simulation

Erez Perelman et. al. @ University of California, San Diego

## 0. Abstract

Modern architecture research relies heavily on detailed pipeline simulation. Simulating the full execution of a single industry standard benchmark at this level of detail takes on the order of months to complete. This problem is exacerbated by the fact that to properly perform an architectural evaluation requires multiple benchmarks to be evaluated across many separate runs. To address this issue we recently created a tool called SimPoint that automatically finds a small set of Simulation Points to represent the complete execution of a program for efficient and accurate simulation. In this paper we describe how to use the SimPoint tool, and introduce an improved SimPoint algorithm designed to significantly reduce the simulation time required when the simulation environment relies upon fast-forwarding.

现代架构研究严重依赖于详细的流水线仿真。将一个工业标准的基准测试，在这种细节的层次上进行完全的仿真执行，需要几个月来完成。要进行一次合理的架构评估，需要多个基准测试运行多次进行评估，这进一步加剧了这个问题。为处理这个问题，我们最近创建了一个工具，叫做SimPoint，可以自动找到一个小的仿真点集合，能代表一个程序的完整执行，可以进行高效准确的仿真。本文中，我们描述了怎样使用SimPoint工具，并提出了一种改进的SimPoint算法，在仿真环境依赖于快进时，设计用于显著减少仿真时间。

**Keywords** SimPoint, Clustering, Simulation, Fast-forwarding, Sampling

## 1. SimPoint

Understanding the cycle level behavior of a processor running an application is crucial to modern computer architecture research. To gain this understanding, detailed cycle level simulators are typically employed. Unfortunately, this level of detail comes at the cost of speed, and simulating the full execution of an industry standard benchmark on even the fastest simulator can take weeks to months to complete. This fact has not gone unnoticed in the academic community, and several researchers have started to develop techniques aimed at reducing simulation time.

理解一个处理器运行一个应用在周期级的行为，对现代计算机架构研究是非常关键的。为获得这种理解，通常采用细节的周期级的仿真器。不幸的是，这种级别的细节的代价是速度，一个工业级的标准基准测试的仿真的完整执行，在最快的仿真器上，也需要几个星期到几个月才能完成。学术界并没有忽视这个事实，几个研究者已经开始开发技术，减少仿真时间。

For architecture research it is often necessary to take one instance of a program with a given input, and simulate its performance over many different architecture configurations. The same program binary with the input may be run hundreds or thousands of times to examine how, for example, the effectiveness of a given architecture changes with its size. Our goal in creating SimPoint [1, 2] is to (1) significantly reduce simulation time, (2) provide an accurate characterization of the full program, and (3) to perform the analysis to accomplish the first two goals in a matter of minutes. These goals are met by simulating only a handful of intelligently chosen sections of the full program. When these sections (simulation points) are carefully chosen, it provides an accurate picture of the complete execution of the program and results in highly accurate estimations of performance.

对于架构研究，通常需要采用一个程序，在给定输入的情况下，在很多种不同的架构配置上，仿真其性能。同一个程序binary，和输入一起，要运行数百或数千次，来检查，比如说，一个给定的架构，在改变其大小时，其有效性。我们创建SimPoint的目标是，(1)显著的减少仿真时间，(2)给出完整程序的准确特征描述，(3)进行分析，以在几分钟内完成前两个目标。要达到这些目标，只需要仿真完整程序的一小部分，但是是智能的选取的几个部分。当这些部分（仿真点）仔细选择后，会给出程序的完整执行的准确代表，给出性能的高度准确的估计。

The key to our approach is that for a given program and input, the simulation points only need to be chosen once. This is because we select them using a method that is independent of any particular architecture configuration. The simulation points are selected using a metric that is only based on the code that is executed over time for a program/input pair. Once the simulation points are chosen they can be used for the hundreds or thousands of independent simulations that may be needed, significantly reducing simulation time.

我们方法的关键是，对于给定的程序和输入，仿真点只需要选择一次。这是因为，我们用于选择的方法，是独立于特定的架构配置的。仿真点的选择所使用的度量，对于一个程序/输入对，只是基于随着时间执行的代码。一旦选择了仿真点，就可以用于数百次上千次的仿真，它们都会需要这些仿真点，显著的减少仿真时间。

To pick the simulation points in [1, 2], we introduce the concept of profiling Basic Block Vectors (BBV) as a way of capturing the important behaviors of the program over time [1]. A Basic Block Vector captures the relative frequency of the code blocks executed during a given portion of execution. After profiling a program with a particular input, we compare the basic block vectors to see how similar they are to one another. Intervals of execution that execute the same code blocks with the same frequency are grouped together into clusters using clustering algorithms from machine learning. We found that sections of execution (represented by basic block vectors) that are grouped into the same cluster have very similar behavior across all the architecture metrics we have examined. Once we break the program into clusters, we pick a single point from each cluster (appropriately weighted) to serve as its representative. The set of representative sections are where detailed simulation is performed. Simulating only these simulation points provides an accurate and efficient representation of the complete execution of the program. All of the code to track the basic blocks, perform the analysis, do the clustering, and pick the simulation points is distributed as part of our SimPoint tool.

为在[1,2]中选择仿真点，我们提出了性能评估的BBV的概念，可用于捕获程序随时间变化的重要行为。BBV捕获的是代码块在给定的执行时间段内的相对频率。在评估了一个程序在给定输入的性能后，我们对BBV进行比较，以比较它们之间的相似程度。以相同频率执行同样代码段的执行片段，分成一个组，称为聚类，使用的是机器学习中的聚类算法。我们发现，分组到相同聚类中的执行片段（以BBV来表示），在我们研究的所有的架构度量下，都有类似的行为。一旦我们将程序分成聚类，我们从每个聚类中选择单个点（进行合适的加权），以作为其代表。代表性片段的集合，是详细仿真进行的地方。对这些仿真点进行仿真，会给出程序完整执行的准确和高效的代表。追踪BB，进行分析，进行聚类，选择仿真点的代码，都是我们的SimPoint工具的一部分。

### 1.1 Using SimPoint for Simulation

A run of the SimPoint tool begins by running each program and input pair through the basic block tracker to generate the basic block vectors. Currently we support gathering the vectors with either ATOM or SimpleScalar. These vectors are then run through the analysis portion of the tool, which does the clustering and generates the points for simulation. One input parameter worth mentioning is the granularity, or interval size. The interval size determines how large of a chuck (in instructions) the program’s execution should be divided into. Therefore, it determines the length of simulation that will be required for any simulation point used. In this paper we use a granularity of 10 million instructions, whereas our prior work [2] used 100 million instructions per simulation point. In addition to setting the granularity, it is also possible to set the ceiling on the maximum number of samples (clusters) you are willing to simulate, and SimPoint will find the most representative simulation points under those constraints. The output from our tool is a set of points to be simulated and their corresponding weights (based on the percent of execution that a given simulation point represents). This is used to weight the corresponding metrics sampled for a simulation point, when combining the results together to get an overall metric for simulating the program/input pair.

SimPoint工具的一次运行，开始时要将每个程序和输入对，通过基础块追踪器运行一次，以生成BBV。目前我们支持的是用ATOM或SimpleScalar来收集这些向量。这些向量然后通过工具的分析部分进行运行，进行聚类，生成仿真点。一个值得提到的输入参数是粒度，或片段大小。片段大小决定了，程序执行应当分成多大的块（以指令条数来说）。因此，这决定了仿真的长度，每个仿真点的粒度都是这个长度。本文中，我们使用一千万条指令的粒度，而我们之前的工作使用每个仿真点一亿条指令的粒度。除了设置粒度，还需要设置要仿真的样本（聚类）的最大数量，SimPoint会在这些约束下，找到最具有代表性的仿真点。我们工具的输出，是要仿真的点集，和它们对应的权重（基于一个给定的仿真点代表的执行比例）。这用于对一个仿真点采样的对应的度量进行加权，然后对这些结果组合到一起，以对仿真程序/输入对得到一个整体的度量。

When using simulation points or sampling, the issue of how to warmup the architecture structures needs to be dealt with. The three approaches we have examined are using checkpoints, stale state, and no warmup at all.

当使用仿真点或采样时，需要处理怎样预热架构结构的问题。我们检查的三个方法，是使用checkpoints，stale state，或没有warmup。

If the simulation environment supports checkpoints, then a checkpoint can be made at the start of each simulation point. This avoids fast-forwarding to each simulation point for each run of the program/input. In addition, all of the simulation points can even be run in parallel to obtain extremely fast results for one particular program/input pair.

如果仿真环境支持checkpoints，那么可以在每个仿真点的开始设一个checkpoint。这避免了对每次程序/输入对的运行中，快进到每个仿真点的动作。此外，所有仿真点甚至可以并行运行，以对一个特定的程序/输入对得到非常快的结果。

If the simulation environment does not support check-pointing, then the simulation must fast-forward between the simulation points. When large simulation intervals are used (e.g., 100 million instructions) we found that no warmup is needed, since any cold-start effects are insignificant in comparison to the effect of execution. If no warmup is used, all of the large architecture structures (e.g., cache, branch predictors) make use of a warmup bit that indicates when the first time an entry is used. If it is the first time, the access is assumed to be a hit or a correct prediction. This a very simple method we added to SimpleScalar, and provides fairly accurate warmup state, since the miss rates for these structures are usually fairly low. For smaller interval sizes (e.g., 10 million) we found that it is beneficial to use Stale State or other proposed warmup techniques to reduce bias from cold-start effects. Stale state is a method of not resetting the architecture structures between simulation points, and instead uses them in the state they were in at the end of the prior simulation point we just fast-forwarded from.

如果仿真环境不支持checkpointing，那么仿真必须要在仿真点之间快进。当使用较大的仿真间隔时（如，一亿条指令），我们发现就不需要warmup了，因为冷启动的效果与执行的效果来比，是不显著的。如果不使用任何warmup，所有大型架构结构（如，cache，分支预测器）使用一个warmup bit，指示一个entry第一次的使用。如果是第一次，这个访问就认为是一次hit，或一个正确的预测。这是一个非常简单的方法，我们加入到了SimpleScalar，来给出比较精确的warmup状态，由于这些结构的miss率是相对较低的。对更小的间隔（如，一千万条指令），我们发现使用stale state或其他提出的warmup技术，来降低cold start的效果。Stale state是在仿真点之间，并不重置架构结构的方法，而是使用之前的快进来的仿真点的状态。

### 1.2 Early Simulation Points

In [2], the goal was to pick a single simulation point from each cluster that best represents all the intervals of execution in that phase. For simulation environments that do not support checkpointing, it can require up to several days to fast-forward to the latter part of the execution if that is where the simulation point is located. Our goal is to find early simulation points to significantly reduce time spent fast-forwarding while still accurately representing the overall execution of the program.

在[2]中，目标是从每个聚类中选择一个仿真点，能最佳代表那个阶段所有的执行片段。对于不支持checkpointing的仿真环境，如果仿真点在执行的后半部分，可能需要好几天来快进到那里。我们的目标是，找到早期的仿真点，以显著降低在快进上耗费的时间，而仍能准确的代表程序的总体执行。

If we consider a simulation environment where multiple points can be simulated one after the other (a single run is done through the program and detailed simulation is interleaved with periods of fast-forwarding), then the last simulation point in program execution order will determine the simulation time. Our Early SimPoint algorithm focuses on choosing a clustering that is both representative of the program’s execution and has some feasible simulation points early in the program for all clusters (if possible). This might not be achievable for all program’s, since an important phase of execution may truly only appear at the end of the program’s execution. We therefore give priority in our algorithm towards still making sure that the clustering represents the overall execution of the program. Once the early clustering is performed, we choose a representative simulation point early in the execution from each cluster.

如果我们考虑一个仿真环境，其中多个点可以一个接一个的仿真（对程序整个进行一次运行，然后细节仿真在多个片段上进行，中间进行快进），然后程序执行顺序中最后的仿真点，会决定仿真时间。我们的早期SimPoint算法聚焦在，选择一个聚类，可以代表程序的执行，而且对所有的聚类，在程序的早期都有可行的仿真点（如果可能的话）。对所有的程序，这并不一定是可行的，因为一个重要的执行阶段可能只会在程序最后的执行阶段出现。我们因此在我们的算法中，要优先确保聚类能代表程序的整体执行。一旦进行了早期聚类，我们在每个聚类的执行的早期，选择一个有代表性的仿真点。

Figure 1 shows the percent error in IPC using simulation points from [2], and Early simulation points. The error is calculated by comparing the estimated error using the different sampling techniques, to the IPC found doing detailed simulation of all the programs to completion. The simulation points from [2] assume perfect warmup, and are collected with interval sizes of 100 million. For the Early results, we used an interval size of 10 million, and each program had less than 30 simulation points. The early simulation points use stale state as described above to reduce bias from cold-start effects. The results show that the early simulation points have a slightly higher error rate, 3.5% on average, over the 2.1% error from the original simulation points from [2].

图1展示了使用[2]中的仿真点，和早期仿真点，所得到IPC百分比误差。误差的计算，是使用不同的采样技术得到的估计误差，与对所有程序进行细节仿真到结束得到的IPC进行比较。[2]中的仿真点假设是完美的warmup，而且是用1亿条指令间隔大小收集的。对于早期结果，我们使用的间隔大小为一千万指令，每个程序的仿真点少于30个。早期仿真点使用stale state，以减少冷启动效果的偏差。结果表明，早期仿真点的错误率略高，平均为3.5%，比[2]的原始仿真点的误差2.1%要高。

In terms of simulation time, Figure 2 shows the number of instructions required to fast-forward for these simulation techniques. Here the benefit of using early simulation points over the former simulation points is clearly seen. The results show that using early simulation points reduces simulation time more than 15 times over the prior SimPoint algorithm in [2].

以仿真时间来说，图2展示了这些仿真技术所需要的快进的指令数量。这里，使用早期仿真点比之前的仿真点的好处可以明显看到。结果表明，使用早期仿真点比之前的SimPoint算法[2]的仿真时间减少了15倍。

Summary: Even on the fastest cycle level simulators, simulating a single minute of real time can take 50 days. Even doing very simple emulation of a program for the purpose of fast-forwarding can take on the order of days. SimPoint is a powerful, available, and easy to use tool for attacking this problem. It requires little or no modification of most cycle level simulators used today, and only needs to be run once per program input pair to pick the simulation points. SimPoint will perform a fully automated analysis of a profile to determine where to best spend limited simulation program analysis resources, and our new Early SimPoint technique makes the approach even faster on simulators without support for check-pointing. Using SimPoint we have found errors always to be less than 8.4%, and even with Early SimPoint the error does not go above 12.2%. Early SimPoint has the benefit that the average fast-forwarding amount is reduced from 167 billion instructions to less than 11 billion instruction.

总结：即使在最快的周期级仿真器中，仿真一分钟的实际时间也需要50天。即使进行程序简单的emulation，其目的是快进，也会需要几天的时间。SimPoint是一种强力的，容易使用的工具，可以解决这个问题。基本不需要对现在使用的多数周期级的仿真器进行修改，对每个程序/输入对，只需要运行一次，以得到仿真点。SimPoint会对profile进行完全自动的分析，以决定对哪里进行仿真程序分析，我们新的Early SimPoint技术使这种方法在仿真器上速度更快，而不需要checkpointing的支持。使用SimPoint，我们发现误差一直小于8.4%，而使用Early SimPoint，误差也没有超过12.2%。Early SimPoint的好处是，平均快进量从1670亿条指令，减少到了110亿条指令。

This work was funded in part by NSF CAREER grant No. CCR-9733278, Semiconductor Research Corporation grant No. SRC-2001-HJ-897, and an equipment grant from Intel.